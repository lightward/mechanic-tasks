{
  "name": "Copy product metafields to each product's tags",
  "options": {
    "metafield_namespace__required": null,
    "metafield_keys_and_tag_prefixes__keyval_required": null,
    "monitor_new_products__boolean": null,
    "test_mode__boolean": null
  },
  "subscriptions": [
    "mechanic/user/trigger"
  ],
  "subscriptions_template": "mechanic/user/trigger\n{% if options.monitor_new_and_updated_products__boolean %}\n  shopify/products/update\n{%endif%}",
  "script": "{% comment %}\n  An opinion about object order:\n\n  {{ options.metafield_namespace__required }}\n  {{ options.metafield_keys_and_tag_prefixes__keyval_required }}\n  {{ options.monitor_new_and_updated_products__boolean }}\n  {{ options.remove_outdated_prefixed_tags__boolean }}\n  {{ options.test_mode__boolean }}\n{% endcomment %}\n\n{% assign metafield_namespace = options.metafield_namespace__required %}\n{% assign metafield_keys_and_tag_prefixes = options.metafield_keys_and_tag_prefixes__keyval_required %}\n{% assign metafield_keys = metafield_keys_and_tag_prefixes | keys %}\n\n{% assign metafields = array %}\n{% assign tag_prefixes_hash = hash %}\n\n{% for keyval in metafield_keys_and_tag_prefixes %}\n  {% assign metafield_key = keyval[0] %}\n  {% assign tag_prefix = keyval[1] %}\n\n  {% if metafield_key != blank %}\n    {% capture metafield %}\n      {{ metafield_key }}: metafield(\n        namespace: {{ metafield_namespace | json }}\n        key: {{ metafield_key | json }}\n      ) {\n        type\n        value\n      }\n    {% endcapture %}\n\n    {% assign metafields = metafields | push: metafield %}\n\n    {% if tag_prefix != blank %}\n      {% assign tag_prefixes_hash[metafield_key] = tag_prefix | lstrip %}\n    {% endif %}\n  {% endif %}\n{% endfor %}\n\n{% assign tag_prefixes = tag_prefixes_hash | values %}\n\n{% assign products = array %}\n\n{% if event.topic == \"mechanic/user/trigger\" or event.topic contains \"mechanic/scheduler/\" %}\n  {% assign cursor = nil %}\n\n  {% for n in (0..1000) %}\n    {% capture query %}\n      query {\n        products(\n          first: 25\n          after: {{ cursor | json }}\n        ) {\n          pageInfo {\n            hasNextPage\n          }\n          edges {\n            cursor\n            node {\n              id\n              tags\n              {{ metafields | join: newline }}\n            }\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = query | shopify %}\n\n    {% assign products_batch = result.data.products.edges | map: \"node\" %}\n\n    {% assign products = products | concat: products_batch %}\n\n    {% if result.data.products.pageInfo.hasNextPage %}\n      {% assign cursor = result.data.products.edges.last.cursor %}\n    {% else %}\n      {% break %}\n    {% endif %}\n  {% endfor %}\n\n{% elsif event.topic contains \"shopify/products/\" %}\n  {% capture query %}\n    query {\n      product(id: {{ product.admin_graphql_api_id | json }}) {\n        id\n        tags\n        {{ metafields | join: newline }}\n      }\n    }\n  {% endcapture %}\n\n  {% assign result = query | shopify %}\n\n  {% assign products[0] = result.data.product %}\n{% endif %}\n\n{% if event.preview %}\n  {% capture products_json %}\n    [\n      {\n        \"id\": \"gid://shopify/Product/1234567890\",\n        \"tags\": [\n          {{ tag_prefixes.first | append: \"sample\" | json }}\n        ],\n        {{ metafield_keys.first | json }}: {\n          \"type\": \"single_line_text_field\",\n          \"value\": \"Lorem ipsum\"\n        }\n      }\n    ]\n  {% endcapture %}\n\n  {% assign products = products_json | parse_json %}\n{% endif %}\n\n{% assign product_ids_and_tags = hash %}\n\n{% for product in products %}\n  {% assign tags_should_have = array %}\n  {% assign tags_to_add = array %}\n  {% assign tags_to_remove = array %}\n\n  {% unless event.preview %}\n    {% log product_before_tagging_updates: product %}\n  {% endunless %}\n\n  {% for metafield_key in metafield_keys %}\n    {% assign tag = nil %}\n    {% assign tag_prefix = tag_prefixes_hash[metafield_key] %}\n    {% assign product_metafield = product[metafield_key] %}\n\n    {% if product_metafield != blank %}\n      {% case product_metafield.type %}\n        {% when \"boolean\" %}\n          {% capture tag %}{{ tag_prefix }}{{ product_metafield.value }}{% endcapture %}\n\n        {% when \"color\" %}\n          {% capture tag %}{{ tag_prefix }}{{ product_metafield.value }}{% endcapture %}\n\n        {% when \"date\" %}\n          {% capture tag %}{{ tag_prefix }}{{ product_metafield.value }}{% endcapture %}\n\n        {% when \"date_time\" %}\n          {% capture tag %}{{ tag_prefix }}{{ product_metafield.value }}{% endcapture %}\n\n        {% when \"dimension\" %}\n          {% assign product_metafield_value = product_metafield.value | parse_json %}\n          {% capture tag %}{{ tag_prefix }}{{ product_metafield_value.value }} {{ product_metafield_value.unit }}{% endcapture %}\n\n        {% when \"number_decimal\" %}\n          {% capture tag %}{{ tag_prefix }}{{ product_metafield.value }}{% endcapture %}\n\n        {% when \"number_integer\" or \"integer\" %}\n          {% capture tag %}{{ tag_prefix }}{{ product_metafield.value }}{% endcapture %}\n\n        {% when \"rating\" %}\n          {% assign product_metafield_value = product_metafield.value | parse_json %}\n          {% capture tag %}{{ tag_prefix }}{{ product_metafield_value.value }} / {{ product_metafield_value.scale_max }}{% endcapture %}\n\n        {% when \"single_line_text_field\" or \"string\" %}\n          {% capture tag %}{{ tag_prefix }}{{ product_metafield.value }}{% endcapture %}\n\n        {% when \"volume\" %}\n          {% assign product_metafield_value = product_metafield.value | parse_json %}\n          {% capture tag %}{{ tag_prefix }}{{ product_metafield_value.value }} {{ product_metafield_value.unit }}{% endcapture %}\n\n        {% when \"weight\" %}\n          {% assign product_metafield_value = product_metafield.value | parse_json %}\n          {% capture tag %}{{ tag_prefix }}{{ product_metafield_value.value }} {{ product_metafield_value.unit }}{% endcapture %}\n\n        {% else %}\n          {% log\n            message: \"Unsupported metafield type for this task\",\n            metafield_type: product_metafield.type,\n            product_id: product.id\n          %}\n      {% endcase %}\n\n      {% if tag %}\n        {% assign tags_should_have = tags_should_have | push: tag %}\n      {% endif %}\n    {% endif %}\n  {% endfor %}\n\n  {% if options.remove_outdated_prefixed_tags__boolean %}\n    {% for tag_prefix in tag_prefixes %}\n      {% assign tag_prefix_size = tag_prefix.size %}\n\n      {% for product_tag in product.tags %}\n        {% assign product_tag_slice = product_tag | slice: 0, tag_prefix_size %}\n\n        {% if product_tag.size > tag_prefix_size and product_tag_slice == tag_prefix %}\n          {% unless tags_should_have contains product_tag %}\n            {% assign tags_to_remove = tags_to_remove | push: product_tag %}\n          {% endunless %}\n        {% endif %}\n      {% endfor %}\n    {% endfor %}\n  {% endif %}\n\n  {% for tag_should_have in tags_should_have %}\n    {% unless product.tags contains tag_should_have %}\n      {% assign tags_to_add = tags_to_add | push: tag_should_have %}\n    {% endunless %}\n  {% endfor %}\n\n  {% if tags_to_add != blank or tags_to_remove != blank %}\n    {% assign product_ids_and_tags[product.id] = hash %}\n    {% assign product_ids_and_tags[product.id][\"tags_to_add\"] = tags_to_add %}\n    {% assign product_ids_and_tags[product.id][\"tags_to_remove\"] = tags_to_remove %}\n\n  {% else %}\n    {% log\n      message: \"No tagging operations needed for this product; skipping.\",\n      product_id: product.id\n    %}\n  {% endif %}\n{% endfor %}\n\n{% if options.test_mode__boolean %}\n  {% action \"echo\" %}\n    {\n      \"message\": \"Found {{ product_ids_and_tags.size }} tagging operations\",\n      \"product_ids_and_tags\": {{ product_ids_and_tags | json }}\n    }\n  {% endaction %}\n\n{% else %}\n  {% for keyval in product_ids_and_tags %}\n    {% assign product_id = keyval[0] %}\n    {% assign tags_to_add = keyval[1].tags_to_add %}\n    {% assign tags_to_remove = keyval[1].tags_to_remove %}\n\n    {% if tags_to_add != blank or tags_to_remove != blank %}\n      {% action \"shopify\" %}\n        mutation {\n          {% if tags_to_add != blank %}\n            tagsAdd(\n              id: {{ product_id | json }}\n              tags: {{ tags_to_add | json }}\n            ) {\n              userErrors {\n                field\n                message\n              }\n            }\n          {% endif %}\n          {% if tags_to_remove != blank %}\n            tagsRemove(\n              id: {{ product_id | json }}\n              tags: {{ tags_to_remove | json }}\n            ) {\n              userErrors {\n                field\n                message\n              }\n            }\n          {% endif %}\n        }\n      {% endaction %}\n    {% endif %}\n  {% endfor %}\n{% endif %}",
  "docs": "This task exists to fill the gap between Shopify's admin product search, and product metafields. Use this task to copy metafield values to product tags, allowing you to filter products by tags based on those metafields.\n\nBegin by entering in the namespace for the metafield(s) you will be configuring for this task. Then, for each metafield, click __Add item__, add the *exact* metafield key on the left, and *optionally* a prefix to apply to tags generated for that specific metafield key. The tag prefix should include any desired demarcation (e.g. spaces, dashes, colons) from the metafield value.\n\nTo have the task remove *prefixed* tags that no longer apply, then enable the __Remove outdated prefixed tags__ option. As an example: if a product has a \"Released: 2021-10-01\" tag, and this task is configured with a \"Released: \" tag prefix, and the associated metafield value changes (or is cleared), then the task can remove the original tag. \n\nWhen run manually, this task scans your entire product catalog. Optionally, you can enable the __Monitor new and updated products__ option to have it also process products as they are created and updated.\n\nIt is *highly* recommended that you first run this task in __Test mode__ and review the task log to see what tags will be set based on your configuration settings, the metafield data, and the task logic for handling each type.\n\nThis task supports the following [Shopify metafield types](https://shopify.dev/apps/metafields/definitions/types): `boolean`, `color`, `date`, `date_time`, `dimension`, `number_decimal`, `number_integer`, `rating`, `single_line_text_field`, `volume`, and `weight`. Support for the deprecated `integer` and `string` types is included by treating them as `number_integer` and `single_line_text_field` types respectively.\n\n__Important Notes:__\n- Be sure to run a full manual scan when new metafield keys are added in this task, so that all of your products can be evaluated with the tagging logic.\n- This task _cannot_ remove outdated tags without prefixes, as it will not be able to identify the outdated values (Shopify does not have any metadata or authorship attached to product tags).  \n- This task only supports a single metafield namespace. If you want to use additional namespaces, then multiple instances of this task can be implemented, each configured with a distinct namespace. __Caution:__ do not use the same tag prefix in multiple instances of this task as then each instance will respond to the other's add/remove tagging actions infinitely.\n- This task is mildly opinionated about the formatting of tags based on the metafield type (e.g. `dimension` metafields will concatenate the value and dimensional unit together with a space.). Each type is broken out within the task code, allowing for easy customization by type.",
  "halt_action_run_sequence_on_error": false,
  "online_store_javascript": null,
  "order_status_javascript": null,
  "perform_action_runs_in_sequence": false,
  "tags": [
    "Metafields",
    "Products",
    "Tag"
  ]
}
