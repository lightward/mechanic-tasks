{
  "name": "Maintain inventory for a product bundle",
  "options": {
    "bundle_product_sku__required": "BUNDLE",
    "component_product_skus_and_quantities_per_bundle__keyval_number_required": {
      "BUNDLE-A": 1,
      "BUNDLE-B": 2,
      "BUNDLE-C": 3
    },
    "inventory_buffer_quantity__number": 1
  },
  "subscriptions": [
    "shopify/orders/create",
    "shopify/refunds/create",
    "shopify/inventory_levels/update",
    "mechanic/user/trigger"
  ],
  "subscriptions_template": "shopify/orders/create\nshopify/refunds/create\nshopify/inventory_levels/update\nmechanic/user/trigger",
  "script": "{% assign bundle_sku = options.bundle_product_sku__required %}\n{% assign component_skus_and_quantities = options.component_product_skus_and_quantities_per_bundle__keyval_number_required %}\n{% assign component_skus = array %}\n{% for keyval in component_skus_and_quantities %}\n  {% assign component_skus[component_skus.size] = keyval.first %}\n{% endfor %}\n{% assign all_skus = array %}\n{% assign all_skus[0] = bundle_sku %}\n{% assign all_skus = all_skus | concat: component_skus %}\n{% assign primary_location = shop.locations[shop.primary_location_id] %}\n{% assign variants_by_sku = hash %}\n\n{% log primary_location: primary_location, bundle_sku: bundle_sku, component_skus_and_quantities: component_skus_and_quantities %}\n\n{% if component_skus.size > 249 %}\n  {% error %}\n  {{ \"This task only supports up to 249 component product SKUs. You've added \" | append: component_skus.size | append: \".\" | json }}\n  {% enderror %}\n{% endif %}\n\n{% assign do_full_sync = false %}\n{% assign do_component_adjustment = false %}\n{% assign component_adjustment_bundle_quantity = nil %}\n\n{% if event.topic == \"mechanic/user/trigger\" %}\n  {% assign do_full_sync = true %}\n{% endif %}\n\n{% if event.topic == \"shopify/orders/create\" %}\n  {% if event.preview %}\n    {% capture order_json %}\n      {\n      \"line_items\": [\n      {\n      \"sku\": {{ bundle_sku | json }},\n      \"quantity\": 1\n      }\n      ]\n      }\n    {% endcapture %}\n\n    {% assign order = order_json | parse_json %}\n  {% endif %}\n\n  {% assign bundle_quantity = order.line_items | where: \"sku\", bundle_sku | map: \"quantity\" | sum %}\n  {% if bundle_quantity != 0 %}\n    {% assign do_component_adjustment = true %}\n    {% assign component_adjustment_bundle_quantity = bundle_quantity | times: -1 %}\n  {% endif %}\n{% endif %}\n\n{% if event.topic == \"shopify/refunds/create\" %}\n  {% if event.preview %}\n    {% capture refund_json %}\n      {\n      \"refund_line_items\": [\n      {\n      \"quantity\": 1,\n      \"restock_type\": \"cancel\",\n      \"line_item\": {\n      \"quantity\": 1,\n      \"sku\": {{ bundle_sku | json }}\n      }\n      }\n      ]\n      }\n    {% endcapture %}\n\n    {% assign refund = refund_json | parse_json %}\n  {% endif %}\n\n  {% assign bundle_restock_quantity = 0 %}\n\n  {% for refund_line_item in refund.refund_line_items %}\n    {% if refund_line_item.line_item.sku == bundle_sku and refund_line_item.restock_type != \"no_restock\" %}\n      {% assign do_component_adjustment = true %}\n      {% assign bundle_restock_quantity = bundle_restock_quantity | plus: refund_line_item.quantity %}\n    {% endif %}\n  {% endfor %}\n\n  {% assign component_adjustment_bundle_quantity = bundle_restock_quantity %}\n{% endif %}\n\n{% if event.topic contains \"shopify/inventory_levels/\" %}\n  {% comment %}\n    Note: we don't use the \"available\" figure that comes in with this payload,\n    to guard against receiving webhooks in the wrong order, or a delay in event\n    processing.\n  {% endcomment %}\n\n  {% capture query %}\n    query {\n    inventoryLevel(id: {{ inventory_level.admin_graphql_api_id | json }}) {\n    item {\n    variant {\n    sku\n    }\n    }\n    }\n    }\n  {% endcapture %}\n\n  {% assign result = query | shopify %}\n\n  {% if event.preview %}\n    {% capture result_json %}\n      {\n      \"data\": {\n      \"inventoryLevel\": {\n      \"item\": {\n      \"variant\": {\n      \"sku\": {{ component_skus.first | json }}\n      }\n      }\n      }\n      }\n      }\n    {% endcapture %}\n\n    {% assign result = result_json | parse_json %}\n  {% endif %}\n\n  {% assign updated_sku = result.data.inventoryLevel.item.variant.sku %}\n\n  {% if all_skus contains updated_sku %}\n    {% assign do_full_sync = true %}\n  {% else %}\n    {% log %}\n    {{ updated_sku | json | prepend: \"Inventory was updated for SKU \" | append: \", which is not related to this bundle.\" | json }}\n    {% endlog %}\n  {% endif %}\n{% endif %}\n\n{% if do_component_adjustment %}\n  {% assign query_components = array %}\n  {% for sku in all_skus %}\n    {% assign query_components[query_components.size] = sku | json | prepend: \"sku:\" %}\n  {% endfor %}\n\n  {% for i in (0..500) %}\n    {% assign cursor = nil %}\n    {% assign after = i | times: 150 %}\n    {% capture query %}\n      query {\n      productVariants(\n      first: 150\n      query: {{ query_components | join: \" OR \" | json }}\n      after: {{ cursor | json }}\n      ) {\n      pageInfo {\n      hasNextPage\n      }\n      edges {\n      cursor\n      node {\n      inventoryQuantity\n      inventoryItem {\n      inventoryLevels(first: 1) {\n      edges {\n      node {\n      id\n      }\n      }\n      }\n      inventoryLevel(locationId: {{ primary_location.admin_graphql_api_id | json }}) {\n      available\n      }\n      }\n      sku\n      }\n      }\n      }\n      }\n    {% endcapture %}\n\n    {% assign result = query | shopify %}\n\n    {% for productVariant_edge in result.data.productVariants.edges %}\n      {% assign variant = productVariant_edge.node %}\n\n      {% if variants_by_sku[variant.sku] == nil %}\n        {% assign variants_by_sku[variant.sku] = array %}\n      {% endif %}\n\n      {% assign _count = variants_by_sku[variant.sku].size %}\n      {% assign variants_by_sku[variant.sku][_count] = variant %}\n    {% endfor %}\n\n    {% if result.data.productVariants.pageInfo.hasNextPage %}\n      {% assign cursor = result.data.productVariants.edges.last.cursor %}\n    {% else %}\n      {% break %}\n    {% endif %}\n\n    {% if event.preview %}\n      {% capture result_json %}\n        {\n        \"data\": {\n        \"productVariants\": {\n        \"edges\": [\n        {% for sku in component_skus %}\n          {\n          \"node\": {\n          \"inventoryItem\": {\n          \"inventoryLevels\": {\n          \"edges\": [\n          {\n          \"node\": {\n          \"id\": \"gid://shopify/InventoryLevel/1234567890?inventory_item_id=1234567890\"\n          }\n          }\n          ]\n          }\n          },\n          \"sku\": {{ sku | json }}\n          }\n          }\n          {% unless forloop.last %},{% endunless %}\n        {% endfor %}\n        ]\n        }\n        }\n        }\n      {% endcapture %}\n\n      {% assign result = result_json | parse_json %}\n    {% endif %}\n\n    {% unless result.data.productVariants.pageInfo.hasNextPage %}\n      {% break %}\n    {% endunless %}\n  {% endfor %}\n\n  {% for pair in variants_by_sku %}\n    {% assign sku = pair[0] %}\n    {% assign variants = pair[1] %}\n    {% assign expected_inventory_quantity = variants[0].inventoryItem.inventoryLevel.available %}\n\n    {% for variant in variants %}\n      {% if variant.inventoryItem.inventoryLevel.available != expected_inventory_quantity %}\n        {% error %}\n        {{ \"Expected all \" | append: sku | append: \" variants to have an inventory quantity of \" | append: expected_inventory_quantity | append: \", but not every variant is at this level. Ensure every variant is in sync, and try again.\" | json }}\n        {% enderror %}\n      {% endif %}\n      {% assign variant_delta = component_adjustment_bundle_quantity | times: component_skus_and_quantities[variant.sku] %}\n      {% if variant_delta == 0 %}\n        {% log \"Component SKU had an inventory that was appropriate for the bundle's current inventory. No change needed.\" %}\n      {% else %}\n        {% action \"shopify\" %}\n        mutation {\n        inventoryAdjustQuantity(\n        input: {\n        inventoryLevelId: {{ variant.inventoryItem.inventoryLevels.edges.first.node.id | json }}\n        availableDelta: {{ variant_delta | json }}\n        }\n        ) {\n        inventoryLevel {\n        id\n        available\n        item {\n        variant {\n        sku\n        }\n        }\n        }\n        userErrors {\n        field\n        message\n        }\n        }\n        }\n        {% endaction %}\n      {% endif %}\n    {% endfor %}\n  {% endfor %}\n{% endif %}\n\n{% if do_full_sync %}\n  {% assign query_components = array %}\n  {% for sku in all_skus %}\n    {% assign query_components[query_components.size] = sku | json | prepend: \"sku:\" %}\n  {% endfor %}\n\n  {% for i in (0..500) %}\n    {% assign cursor = nil %}\n    {% assign after = i | times: 150 %}\n    {% capture query %}\n      query {\n      productVariants(\n      first: 150\n      query: {{ query_components | join: \" OR \" | json }}\n      after: {{ cursor | json }}\n      ) {\n      pageInfo {\n      hasNextPage\n      }\n      edges {\n      cursor\n      node {\n      inventoryQuantity\n      inventoryItem {\n      inventoryLevels(first: 1) {\n      edges {\n      node {\n      id\n      }\n      }\n      }\n      inventoryLevel(locationId: {{ primary_location.admin_graphql_api_id | json }}) {\n      available\n      }\n      }\n      sku\n      }\n      }\n      }\n      }\n    {% endcapture %}\n\n    {% assign result = query | shopify %}\n\n    {% for productVariant_edge in result.data.productVariants.edges %}\n      {% assign variant = productVariant_edge.node %}\n\n      {% if variants_by_sku[variant.sku] == nil %}\n        {% assign variants_by_sku[variant.sku] = array %}\n      {% endif %}\n\n      {% assign _count = variants_by_sku[variant.sku].size %}\n      {% assign variants_by_sku[variant.sku][_count] = variant %}\n    {% endfor %}\n\n    {% if result.data.productVariants.pageInfo.hasNextPage %}\n      {% assign cursor = result.data.productVariants.edges.last.cursor %}\n    {% else %}\n      {% break %}\n    {% endif %}\n\n    {% if event.preview %}\n      {% capture result_json %}\n        {\n        \"data\": {\n        \"productVariants\": {\n        \"edges\": [\n        {\n        \"node\": {\n        \"inventoryItem\": {\n        \"inventoryLevels\": {\n        \"edges\": [\n        {\n        \"node\": {\n        \"id\": \"gid://shopify/InventoryLevel/1234567890?inventory_item_id=1234567890\"\n        }\n        }\n        ]\n        }\n        },\n        \"inventoryQuantity\": 2,\n        \"sku\": {{ bundle_sku | json }}\n        }\n        },\n        {% for sku in component_skus %}\n          {\n          \"node\": {\n          \"inventoryItem\": {\n          \"inventoryLevels\": {\n          \"edges\": [\n          {\n          \"node\": {\n          \"id\": \"gid://shopify/InventoryLevel/1234567890?inventory_item_id=1234567890\"\n          }\n          }\n          ]\n          }\n          },\n          \"inventoryQuantity\": 1,\n          \"sku\": {{ sku | json }}\n          }\n          }\n          {% unless forloop.last %},{% endunless %}\n        {% endfor %}\n        ]\n        }\n        }\n        }\n      {% endcapture %}\n\n      {% assign result = result_json | parse_json %}\n    {% endif %}\n\n    {% unless result.data.productVariants.pageInfo.hasNextPage %}\n      {% break %}\n    {% endunless %}\n  {% endfor %}\n\n  {% for pair in variants_by_sku %}\n    {% assign sku = pair[0] %}\n    {% assign variants = pair[1] %}\n    {% assign expected_inventory_quantity = variants[0].inventoryItem.inventoryLevel.available %}\n    {% for variant in variants %}\n      {% if variant.inventoryItem.inventoryLevel.available != expected_inventory_quantity %}\n        {% error %}\n        {{ \"Expected all \" | append: sku | append: \" variants to have an inventory quantity of \" | append: expected_inventory_quantity | append: \", but not every variant is at this level. Ensure every variant is in sync, and try again.\" | json }}\n        {% enderror %}\n      {% endif %}\n      {% if variant.sku == bundle_sku %}\n        {% assign bundle_variant = variant %}\n      {% elsif component_skus contains variant.sku %}\n        {% assign variant_bundle_quantity = variant.inventoryQuantity | times: 1.0 | divided_by: component_skus_and_quantities[variant.sku] %}\n\n        {% if minimum_inventory_variant == nil or minimum_inventory_variant_bundle_quantity > variant_bundle_quantity %}\n          {% assign minimum_inventory_variant = variant %}\n          {% assign minimum_inventory_variant_bundle_quantity = variant_bundle_quantity %}\n        {% endif %}\n      {% endif %}\n    {% endfor %}\n  {% endfor %}\n\n  {% assign bundle_delta = minimum_inventory_variant_bundle_quantity | floor | minus: bundle_variant.inventoryQuantity %}\n\n  {% if options.inventory_buffer_quantity__number != blank %}\n    {% assign bundle_delta = bundle_delta | minus: options.inventory_buffer_quantity__number %}\n  {% endif %}\n\n  {% log bundle_variant_id: bundle_variant.inventoryItem.inventoryLevels.edges.first.node.id, available_delta: bundle_delta, minimum_inventory_variant_sku: minimum_inventory_variant.sku, minimum_inventory_variant_quantity: minimum_inventory_variant.inventoryQuantity, minimum_inventory_variant_bundle_quantity: minimum_inventory_variant_bundle_quantity %}\n\n  {% if bundle_delta == 0 %}\n    {% log \"Lowest quantity component SKU had an inventory that was appropriate for the bundle's current inventory. No change needed.\" %}\n  {% else %}\n    {% action \"shopify\" %}\n    mutation {\n    inventoryAdjustQuantity(\n    input: {\n    inventoryLevelId: {{ bundle_variant.inventoryItem.inventoryLevels.edges.first.node.id | json }}\n    availableDelta: {{ bundle_delta | json }}\n    }\n    ) {\n    inventoryLevel {\n    id\n    available\n    item {\n    variant {\n    sku\n    }\n    }\n    }\n    userErrors {\n    field\n    message\n    }\n    }\n    }\n    {% endaction %}\n  {% endif %}\n{% endif %}",
  "docs": "Use this task to automatically sync inventory for a simple product bundle – no theme modifications required. When configured with unique SKUs for the bundle and its components, and with quantities needed from each component for each bundle unit, this task keeps the bundle inventory set to the greatest possible value, given the quantities of its components. It also appropriately subtracts from component inventory whenever the bundle is ordered, and appropriately raises component inventory when a bundle order is refunded.\n\nUsage:\n\n* Run this task manually to sync the bundle's inventory with that of the component product that has the least inventory in stock.\n* This task will run automatically whenever the bundle product is ordered, and whenever the bundle product is refunded in such a way that it is restocked.\n\nRequirements:\n\n* This task does not support multiple inventory locations.\n* Configure this task with unique SKUs for the bundle product.\n* Bundle Components can be duplicate SKU's, however, all duplicate SKU's must have the same inventory level. \n* Use the right-hand side of the \"Component product SKUs and quantities per bundle\" option to control how many units of each component SKU is required for each single bundle unit. If your bundle requires one wrench and two sprockets, for example, make sure to add \"1\" and \"2\" on the right-hand side, each number associated with the right SKU.\n\nNotes:\n\n* Whenever this task runs, any inventory updates to the bundle product will be overwritten. For the purposes of this task, the bundle's inventory is exclusively derived from the inventory of its components. (This also means that this task does not support \"nested\" bundles, in which a bundle component product is itself a bundle managed by another copy of this task.)\n* Feel free to manually adjust inventory for component products. The bundle product's inventory will be synced appropriately.\n* Use the \"Inventory buffer quantity\" option to artificially keep the bundle product's inventory lower than the actual available quantity.",
  "halt_action_run_sequence_on_error": false,
  "liquid_profiling": false,
  "online_store_javascript": null,
  "order_status_javascript": null,
  "perform_action_runs_in_sequence": false,
  "shopify_api_version": "2021-01"
}