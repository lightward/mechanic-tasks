{
  "name": "Maintain inventory for a product bundle",
  "options": {
    "bundle_product_sku__required": "BUNDLE",
    "component_product_skus_and_quantities_per_bundle__keyval_number_required": {
      "BUNDLE-A": 1,
      "BUNDLE-B": 2,
      "BUNDLE-C": 3
    },
    "inventory_buffer_quantity__number": 1
  },
  "subscriptions": [
    "shopify/orders/create",
    "shopify/refunds/create",
    "shopify/inventory_levels/update",
    "mechanic/user/trigger"
  ],
  "subscriptions_template": "shopify/orders/create\nshopify/refunds/create\nshopify/inventory_levels/update\nmechanic/user/trigger",
  "script": "{% assign bundle_sku = options.bundle_product_sku__required %}\n{% assign component_skus_and_quantities = options.component_product_skus_and_quantities_per_bundle__keyval_number_required %}\n{% assign component_skus = array %}\n{% for keyval in component_skus_and_quantities %}\n  {% assign component_skus[component_skus.size] = keyval.first %}\n{% endfor %}\n{% assign all_skus = array %}\n{% assign all_skus[0] = bundle_sku %}\n{% assign all_skus = all_skus | concat: component_skus %}\n\n{% log bundle_sku: bundle_sku, component_skus_and_quantities: component_skus_and_quantities %}\n\n{% if component_skus.size > 249 %}\n  {% error %}\n    {{ \"This task only supports up to 249 component product SKUs. You've added \" | append: component_skus.size | append: \".\" | json }}\n  {% enderror %}\n{% endif %}\n\n{% assign do_full_sync = false %}\n{% assign do_component_adjustment = false %}\n{% assign component_adjustment_bundle_quantity = nil %}\n\n{% if event.topic == \"mechanic/user/trigger\" %}\n  {% assign do_full_sync = true %}\n{% endif %}\n\n{% if event.topic == \"shopify/orders/create\" %}\n  {% if event.preview %}\n    {% capture order_json %}\n      {\n        \"line_items\": [\n          {\n            \"sku\": {{ bundle_sku | json }},\n            \"quantity\": 1\n          }\n        ]\n      }\n    {% endcapture %}\n\n    {% assign order = order_json | parse_json %}\n  {% endif %}\n\n  {% assign bundle_quantity = order.line_items | where: \"sku\", bundle_sku | map: \"quantity\" | sum %}\n  {% if bundle_quantity != 0 %}\n    {% assign do_component_adjustment = true %}\n    {% assign component_adjustment_bundle_quantity = bundle_quantity | times: -1 %}\n  {% endif %}\n{% endif %}\n\n{% if event.topic == \"shopify/refunds/create\" %}\n  {% if event.preview %}\n    {% capture refund_json %}\n      {\n        \"refund_line_items\": [\n          {\n            \"quantity\": 1,\n            \"restock_type\": \"cancel\",\n            \"line_item\": {\n              \"quantity\": 1,\n              \"sku\": {{ bundle_sku | json }}\n            }\n          }\n        ]\n      }\n    {% endcapture %}\n\n    {% assign refund = refund_json | parse_json %}\n  {% endif %}\n\n  {% assign bundle_restock_quantity = 0 %}\n\n  {% for refund_line_item in refund.refund_line_items %}\n    {% if refund_line_item.line_item.sku == bundle_sku and refund_line_item.restock_type != \"no_restock\" %}\n      {% assign do_component_adjustment = true %}\n      {% assign bundle_restock_quantity = bundle_restock_quantity | plus: refund_line_item.quantity %}\n    {% endif %}\n  {% endfor %}\n\n  {% assign component_adjustment_bundle_quantity = bundle_restock_quantity %}\n{% endif %}\n\n{% if event.topic contains \"shopify/inventory_levels/\" %}\n  {% comment %}\n    Note: we don't use the \"available\" figure that comes in with this payload,\n    to guard against receiving webhooks in the wrong order, or a delay in event\n    processing.\n  {% endcomment %}\n\n  {% capture query %}\n    query {\n      inventoryLevel(id: {{ inventory_level.admin_graphql_api_id | json }}) {\n        item {\n          variant {\n            sku\n          }\n        }\n      }\n    }\n  {% endcapture %}\n\n  {% assign result = query | shopify %}\n\n  {% if event.preview %}\n    {% capture result_json %}\n      {\n        \"data\": {\n          \"inventoryLevel\": {\n            \"item\": {\n              \"variant\": {\n                \"sku\": {{ component_skus.first | json }}\n              }\n            }\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = result_json | parse_json %}\n  {% endif %}\n\n  {% assign updated_sku = result.data.inventoryLevel.item.variant.sku %}\n\n  {% if all_skus contains updated_sku %}\n    {% assign do_full_sync = true %}\n  {% else %}\n    {% log %}\n      {{ updated_sku | json | prepend: \"Inventory was updated for SKU \" | append: \", which is not related to this bundle.\" | json }}\n    {% endlog %}\n  {% endif %}\n{% endif %}\n\n{% if do_component_adjustment %}\n  {% assign query_components = array %}\n  {% for sku in component_skus %}\n    {% assign query_components[query_components.size] = sku | json | prepend: \"sku:\" %}\n  {% endfor %}\n\n  {% capture query %}\n    query {\n      productVariants(\n        first: {{ component_skus.size | json }}\n        query: {{ query_components | join: \" OR \" | json }}\n      ) {\n        edges {\n          node {\n            inventoryItem {\n              inventoryLevels(first: 1) {\n                edges {\n                  node {\n                    id\n                  }\n                }\n              }\n            }\n            sku\n          }\n        }\n      }\n    }\n  {% endcapture %}\n\n  {% assign result = query | shopify %}\n\n  {% if event.preview %}\n    {% capture result_json %}\n      {\n        \"data\": {\n          \"productVariants\": {\n            \"edges\": [\n              {% for sku in component_skus %}\n                {\n                  \"node\": {\n                    \"inventoryItem\": {\n                      \"inventoryLevels\": {\n                        \"edges\": [\n                          {\n                            \"node\": {\n                              \"id\": \"gid://shopify/InventoryLevel/1234567890?inventory_item_id=1234567890\"\n                            }\n                          }\n                        ]\n                      }\n                    },\n                    \"sku\": {{ sku | json }}\n                  }\n                }\n                {% unless forloop.last %},{% endunless %}\n              {% endfor %}\n            ]\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = result_json | parse_json %}\n  {% endif %}\n\n  {% assign variants = result.data.productVariants.edges | map: \"node\" %}\n  {% assign found_skus = variants | map: \"sku\" | uniq %}\n\n  {% if variants.size != component_skus.size or found_skus.size != variants.size %}\n    {% error %}\n      {{ \"Expected to find \" | append: component_skus.size | append: \" matching component product variants with unique SKUs, based on the task configuration, but found \" | append: variants.size | append: \" matching variants with \" | append: found_skus.size | append: \" unique SKUs instead. Make sure each SKU for this task only has one associated product in your store.\" | json }}\n    {% enderror %}\n  {% endif %}\n\n  {% action \"shopify\" %}\n    mutation {\n      {% for variant in variants %}\n        {% assign variant_delta = component_adjustment_bundle_quantity | times: component_skus_and_quantities[variant.sku] %}\n\n        inventoryAdjustQuantity{{ forloop.index }}: inventoryAdjustQuantity(\n          input: {\n            inventoryLevelId: {{ variant.inventoryItem.inventoryLevels.edges.first.node.id | json }}\n            availableDelta: {{ variant_delta | json }}\n          }\n        ) {\n          inventoryLevel {\n            id\n            available\n            item {\n              variant {\n                sku\n              }\n            }\n          }\n          userErrors {\n            field\n            message\n          }\n        }\n      {% endfor %}\n    }\n  {% endaction %}\n{% endif %}\n\n{% if do_full_sync %}\n  {% assign query_components = array %}\n  {% for sku in all_skus %}\n    {% assign query_components[query_components.size] = sku | json | prepend: \"sku:\" %}\n  {% endfor %}\n\n  {% capture query %}\n    query {\n      productVariants(\n        first: {{ all_skus.size | json }}\n        query: {{ query_components | join: \" OR \" | json }}\n      ) {\n        edges {\n          node {\n            inventoryQuantity\n            inventoryItem {\n              inventoryLevels(first: 1) {\n                edges {\n                  node {\n                    id\n                  }\n                }\n              }\n            }\n            sku\n          }\n        }\n      }\n    }\n  {% endcapture %}\n\n  {% assign result = query | shopify %}\n\n  {% if event.preview %}\n    {% capture result_json %}\n      {\n        \"data\": {\n          \"productVariants\": {\n            \"edges\": [\n              {\n                \"node\": {\n                  \"inventoryItem\": {\n                    \"inventoryLevels\": {\n                      \"edges\": [\n                        {\n                          \"node\": {\n                            \"id\": \"gid://shopify/InventoryLevel/1234567890?inventory_item_id=1234567890\"\n                          }\n                        }\n                      ]\n                    }\n                  },\n                  \"inventoryQuantity\": 2,\n                  \"sku\": {{ bundle_sku | json }}\n                }\n              },\n              {% for sku in component_skus %}\n                {\n                  \"node\": {\n                    \"inventoryItem\": {\n                      \"inventoryLevels\": {\n                        \"edges\": [\n                          {\n                            \"node\": {\n                              \"id\": \"gid://shopify/InventoryLevel/1234567890?inventory_item_id=1234567890\"\n                            }\n                          }\n                        ]\n                      }\n                    },\n                    \"inventoryQuantity\": 1,\n                    \"sku\": {{ sku | json }}\n                  }\n                }\n                {% unless forloop.last %},{% endunless %}\n              {% endfor %}\n            ]\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = result_json | parse_json %}\n  {% endif %}\n\n  {% assign variants = result.data.productVariants.edges | map: \"node\" %}\n  {% assign found_skus = variants | map: \"sku\" | uniq %}\n\n  {% if variants.size != all_skus.size or found_skus.size != variants.size %}\n    {% error %}\n      {{ \"Expected to find \" | append: all_skus.size | append: \" matching component product variants with unique SKUs, based on the task configuration, but found \" | append: variants.size | append: \" matching variants with \" | append: found_skus.size | append: \" unique SKUs instead. Make sure each SKU for this task only has one associated product in your store.\" | json }}\n    {% enderror %}\n  {% endif %}\n\n  {% assign minimum_inventory_variant = nil %}\n  {% assign minimum_inventory_variant_bundle_quantity = nil %}\n  {% assign bundle_variant = nil %}\n\n  {% for variant in variants %}\n    {% if variant.sku == bundle_sku %}\n      {% assign bundle_variant = variant %}\n    {% elsif component_skus contains variant.sku %}\n      {% assign variant_bundle_quantity = variant.inventoryQuantity | times: 1.0 | divided_by: component_skus_and_quantities[variant.sku] %}\n\n      {% if minimum_inventory_variant == nil or minimum_inventory_variant_bundle_quantity > variant_bundle_quantity %}\n        {% assign minimum_inventory_variant = variant %}\n        {% assign minimum_inventory_variant_bundle_quantity = variant_bundle_quantity %}\n      {% endif %}\n    {% endif %}\n  {% endfor %}\n\n  {% assign bundle_delta = minimum_inventory_variant_bundle_quantity | floor | minus: bundle_variant.inventoryQuantity %}\n\n  {% if options.inventory_buffer_quantity__number != blank %}\n    {% assign bundle_delta = bundle_delta | minus: options.inventory_buffer_quantity__number %}\n  {% endif %}\n\n  {% log minimum_inventory_variant_sku: minimum_inventory_variant.sku, minimum_inventory_variant_quantity: minimum_inventory_variant.inventoryQuantity, minimum_inventory_variant_bundle_quantity: minimum_inventory_variant_bundle_quantity %}\n\n  {% if bundle_delta == 0 %}\n    {% log \"Lowest quantity component SKU had an inventory that was appropriate for the bundle's current inventory. No change needed.\" %}\n  {% else %}\n    {% action \"shopify\" %}\n      mutation {\n        inventoryAdjustQuantity(\n          input: {\n            inventoryLevelId: {{ bundle_variant.inventoryItem.inventoryLevels.edges.first.node.id | json }}\n            availableDelta: {{ bundle_delta | json }}\n          }\n        ) {\n          inventoryLevel {\n            id\n            available\n            item {\n              variant {\n                sku\n              }\n            }\n          }\n          userErrors {\n            field\n            message\n          }\n        }\n      }\n    {% endaction %}\n  {% endif %}\n{% endif %}",
  "docs": "Use this task to automatically sync inventory for a simple product bundle – no theme modifications required. When configured with unique SKUs for the bundle and its components, and with quantities needed from each component for each bundle unit, this task keeps the bundle inventory set to the greatest possible value, given the quantities of its components. It also appropriately subtracts from component inventory whenever the bundle is ordered, and appropriately raises component inventory when a bundle order is refunded.\n\nUsage:\r\n\r\n* Run this task manually to sync the bundle's inventory with that of the component product that has the least inventory in stock.\r\n* This task will run automatically whenever the bundle product is ordered, and whenever the bundle product is refunded in such a way that it is restocked.\r\n\r\nRequirements:\r\n\r\n* This task does not support multiple inventory locations.\r\n* Configure this task with unique SKUs for the bundle product and its component products. These SKUs must not be re-used for any other product variants in your store. However, any component SKU may be used for multiple copies of this task.\r\n* Use the right-hand side of the \"Component product SKUs and quantities per bundle\" option to control how many units of each component SKU is required for each single bundle unit. If your bundle requires one wrench and two sprockets, for example, make sure to add \"1\" and \"2\" on the right-hand side, each number associated with the right SKU.\r\n\r\nNotes:\r\n\r\n* Whenever this task runs, manual inventory updates to the bundle product will be overwritten.\r\n* Feel free to manually adjust inventory for component products. The bundle product's inventory will be synced appropriately.\r\n* Use the \"Inventory buffer quantity\" option to artificially keep the bundle product's inventory lower than the actual available quantity.",
  "halt_action_run_sequence_on_error": false,
  "online_store_javascript": null,
  "order_status_javascript": null,
  "perform_action_runs_in_sequence": false
}
