{
  "docs": "This task re-sorts your collections by the product property, product metafield, or variant property that you choose. Use the \"Product property\" or \"First variant property\" options to control what attribute the task looks up. For example, using `publishedAt` in the \"Product property\" field will result in sorting by the date and time the product was published, while using `sku` in the \"First variant property\" field will result in sorting by the sku of the first variant of each product in the collection. Alternatively, enter a product metafield as \"namespace.key\" (e.g. `store.priority`), and the task will attempt to sort by the value of that metafield.\n\nRun this task manually to re-sort your collections on demand, or choose to run it hourly or nightly. This task will scan all collections in the shop on each run, unless you configure it to only sort certain collections using each collection's title, handle, or ID. Optionally, choose the \"Reverse sort\" option to have the results reversed, mainly useful for sorting by descending numeric values (e.g. `inventoryTotal`).\n\n**Important:**\n\n- You may only choose one sorting method.\n- The collections processed by this task must be configured for manual sorting, otherwise they will be ignored.\n- The property you choose should be a `DateTime`, `Int`, or `String` field on the [GraphQL Product](https://shopify.dev/docs/api/admin-graphql/latest/objects/Product) or [GraphQL ProductVariant](https://shopify.dev/docs/api/admin-graphql/latest/objects/ProductVariant) resource, otherwise the task will generate an error during execution. For help migrating from prior versions of this task, Shopify has documented the mappings for [REST product properties](https://shopify.dev/docs/api/admin-rest/latest/resources/product) and [REST product variant properties](https://shopify.dev/docs/api/admin-rest/latest/resources/product-variant) to GraphQL. (e.g. REST: `published_at` => GraphQL: `publishedAt`)\n- Products with values for a property/metafield will always be placed before products with no values. This rule applies even when the sort order is reversed.\n- If a metafield is configured that does not exist, the task will just report that no moves are needed. No error will be thrown.",
  "halt_action_run_sequence_on_error": false,
  "name": "Auto-sort collections by a product property",
  "online_store_javascript": null,
  "options": {
    "product_property": "publishedAt",
    "product_metafield": "",
    "first_variant_property": "",
    "only_sort_these_collections__array": null,
    "reverse_sort__boolean": false,
    "run_hourly__boolean": false,
    "run_daily__boolean": false
  },
  "order_status_javascript": null,
  "perform_action_runs_in_sequence": false,
  "script": "{% assign product_property = options.product_property %}\n{% assign product_metafield = options.product_metafield %}\n{% assign first_variant_property = options.first_variant_property %}\n{% assign only_sort_these_collections = options.only_sort_these_collections__array %}\n{% assign reverse_sort = options.reverse_sort__boolean %}\n\n{% comment %}\n  -- build the query fragment for the configured property\n{% endcomment %}\n\n{% assign property_fields_count = 0 %}\n\n{% if product_property != blank %}\n  {% assign property_fields_count = property_fields_count | plus: 1 %}\n{% endif %}\n\n{% if product_metafield != blank %}\n  {% assign property_fields_count = property_fields_count | plus: 1 %}\n{% endif %}\n\n{% if first_variant_property != blank %}\n  {% assign property_fields_count = property_fields_count | plus: 1 %}\n{% endif %}\n\n{% if property_fields_count != 1 %}\n  {% error \"Configure one (and only one) of these options: 'Product property', 'Product metafield', or 'First variant property'\" %}\n  {% break %}\n{% endif %}\n\n{% assign query_fragment = nil %}\n\n{% if product_property != blank %}\n  {% assign query_fragment = product_property %}\n\n{% elsif product_metafield != blank %}\n  {%- capture query_fragment -%}\n    metafield(key: {{ product_metafield | json }}) {\n      value\n    }\n  {%- endcapture -%}\n\n{% elsif first_variant_property != blank %}\n  {%- capture query_fragment -%}\n    variants(first: 1) {\n      nodes {\n        {{ first_variant_property }}\n      }\n    }\n  {%- endcapture -%}\n{% endif %}\n\n{% if event.topic == \"mechanic/user/trigger\" or event.topic contains \"mechanic/scheduler/\" %}\n  {% comment %}\n    -- get IDs for all manually sorted collections, optionally restricted to specific collections by ID or title\n  {% endcomment %}\n\n  {% assign collection_ids_to_sort = array %}\n  {% assign cursor = nil %}\n\n  {% for n in (1..50) %}\n    {% capture query %}\n      query {\n        collections(\n          first: 250\n          after: {{ cursor | json }}\n        ) {\n          pageInfo {\n            hasNextPage\n            endCursor\n          }\n          nodes {\n            id\n            legacyResourceId\n            title\n            handle\n            sortOrder\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = query | shopify %}\n\n    {% if event.preview %}\n      {% capture result_json %}\n        {\n          \"data\": {\n            \"collections\": {\n              \"nodes\": [\n                {\n                  \"id\": \"gid://shopify/Collection/1234567890\",\n                  \"legacyResourceId\": \"1234567890\",\n                  \"sortOrder\": \"MANUAL\"\n                }\n              ]\n            }\n          }\n        }\n      {% endcapture %}\n\n      {% assign result = result_json | parse_json %}\n    {% endif %}\n\n    {% comment %}\n      -- loop through collections and filter by ID, title, or handle as configured\n    {% endcomment %}\n\n    {% for collection in result.data.collections.nodes %}\n      {% if only_sort_these_collections != blank %}\n        {% unless only_sort_these_collections contains collection.legacyResourceId\n          or only_sort_these_collections contains collection.title\n          or only_sort_these_collections contains collection.handle\n          or event.preview\n        %}\n          {% continue %}\n        {% endunless %}\n      {% endif %}\n\n      {% if collection.sortOrder != \"MANUAL\" %}\n        {% log %}\n          {{ collection.title | json | append: \" is not configured for manual sorting; skipping.\" | json }}\n        {% endlog %}\n        {% continue %}\n      {% endif %}\n\n      {% assign collection_ids_to_sort = collection_ids_to_sort | push: collection.id %}\n    {% endfor %}\n\n    {% if result.data.collections.pageInfo.hasNextPage %}\n      {% assign cursor = result.data.collections.pageInfo.endCursor %}\n    {% else %}\n      {% break %}\n    {% endif %}\n  {% endfor %}\n\n  {% if collection_ids_to_sort == blank %}\n    {% log \"None of the configured collections were found or set for manual sorting.\" %}\n    {% break %}\n  {% endif %}\n\n  {% comment %}\n    -- save the qualified collection IDs to the cache for lookup in later child events\n    -- NOTE: using event ID instead of task ID in case one instance of this task runs concurrent with another\n  {% endcomment %}\n\n  {% assign cache_key = event.id | prepend: \"collection_ids_to_sort_\" %}\n  {% action \"cache\", \"set\", cache_key, collection_ids_to_sort %}\n\n  {% log\n    message: \"Begin processing collections loop using sequential child events.\",\n    total_collections_to_sort: collection_ids_to_sort.size\n  %}\n\n  {% action \"event\" %}\n    {\n      \"topic\": \"user/collection_sort/process\",\n      \"task_id\": {{ task.id | json }},\n      \"data\": {\n        \"cache_key\": {{ cache_key | json }},\n        \"cache_index\": 0\n      }\n    }\n  {% endaction %}\n\n{% elsif event.topic == \"user/collection_sort/process\" %}\n  {% assign cache_key = event.data.cache_key %}\n  {% assign cache_index = event.data.cache_index %}\n  {% assign collection_ids_to_sort = cache[cache_key] %}\n  {% assign collection_id = collection_ids_to_sort[cache_index] %}\n\n  {% assign moves = array %}\n  {% assign product_ids_and_positions = hash %}\n  {% assign product_ids_and_values = array %}\n\n  {% assign cursor = nil %}\n  {% assign products = array %}\n\n  {% for n in (1..100) %}\n    {% capture query %}\n      query {\n        collection(id: {{ collection_id | json }}) {\n          id\n          title\n          products(\n            first: 250\n            after: {{ cursor | json }}\n            sortKey: COLLECTION_DEFAULT\n          ) {\n            pageInfo {\n              hasNextPage\n              endCursor\n            }\n            nodes {\n              id\n              {{ query_fragment }}\n            }\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = query | shopify %}\n\n    {% if event.preview %}\n      {% capture result_json %}\n        {\n          \"data\": {\n            \"collection\": {\n              \"id\": \"gid://shopify/Collection/1234567890\",\n              \"title\": \"Widgets\",\n              \"products\": {\n                \"nodes\": [\n                  {\n                    \"id\": \"gid://shopify/Product/1234567890\"\n                  },\n                  {\n                    \"id\": \"gid://shopify/Product/2345678901\"\n                  }\n                ]\n              }\n            }\n          }\n        }\n      {% endcapture %}\n\n      {% assign result = result_json | parse_json %}\n    {% endif %}\n\n    {% assign collection = result.data.collection %}\n    {% assign products = products | concat: result.data.collection.products.nodes %}\n\n    {% if result.data.products.pageInfo.hasNextPage %}\n      {% assign cursor = result.data.products.pageInfo.endCursor %}\n    {% else %}\n      {% break %}\n    {% endif %}\n  {% endfor %}\n\n  {% log collection_products: products %}\n\n  {% for product in products %}\n    {% assign product_ids_and_positions[product.id] = forloop.index0 %}\n\n    {% assign product_id_and_value = hash %}\n    {% assign product_id_and_value[\"id\"] = product.id %}\n\n    {% if product_property != blank %}\n      {% assign value = product[product_property] %}\n\n    {% elsif product_metafield != blank %}\n      {% assign value = product.metafield.value %}\n\n    {% elsif first_variant_property != blank %}\n      {% assign value = product.variants.nodes.first[first_variant_property] %}\n    {% endif %}\n\n    {% comment %}\n      -- make sure this is always a serializable/sortable object, defaulting to nil in the case of an empty string\n      -- values which are *either* nil or an empty string will always end up at the end of the list\n    {% endcomment %}\n\n    {% assign product_id_and_value[\"value\"] = value | json | parse_json | default: nil %}\n    {% assign product_ids_and_values[product_ids_and_values.size] = product_id_and_value %}\n  {% endfor %}\n\n  {% assign sorted_product_values = product_ids_and_values | sort: \"value\" %}\n  {% assign sorted_product_ids = sorted_product_values | map: \"id\" %}\n\n  {% if reverse_sort %}\n    {% comment %}\n      -- only reverse the order of products which have values, leaving nil values at the end\n    {% endcomment %}\n\n    {% assign sorted_product_ids\n      = sorted_product_values\n      | where: \"value\"\n      | map: \"id\"\n      | reverse\n      | concat: sorted_product_ids\n      | uniq\n    %}\n  {% endif %}\n\n  {% log sorted_product_ids: sorted_product_ids %}\n\n  {% comment %}\n    -- determine the moves necessary to place products in their sorted positions\n  {% endcomment %}\n\n  {% for sorted_product_id in sorted_product_ids %}\n    {% if forloop.index0 != product_ids_and_positions[sorted_product_id] %}\n      {% assign move = hash %}\n      {% assign move[\"id\"] = sorted_product_id %}\n      {% assign move[\"newPosition\"] = \"\" | append: forloop.index0 %}\n      {% assign moves[moves.size] = move %}\n    {% endif %}\n  {% endfor %}\n\n  {% comment %}\n    -- add preview here so collectionReorderProducts is reached, and the proper scopes are requested\n  {% endcomment %}\n\n  {% if event.preview %}\n    {% capture moves_json %}\n      [\n        {\n          \"id\": \"gid://shopify/Product/1234567890\",\n          \"newPosition\": \"1\"\n        },\n        {\n          \"id\": \"gid://shopify/Product/2345678901\",\n          \"newPosition\": \"0\"\n        }\n      ]\n    {% endcapture %}\n\n    {% assign moves = moves_json | parse_json %}\n  {% endif %}\n\n  {% if moves == blank %}\n    {% log\n      message: \"No moves necessary for this collection, everything is already in its appropriate sort order.\",\n      collection: collection.title\n    %}\n\n  {% else %}\n    {% log\n      message: \"Collection requires sorting.\",\n      collection: collection.title\n    %}\n\n    {% comment %}\n      -- using reverse filter below due to a bug in the collectionReorderProducts mutation\n      -- this filter will NOT affect the sort order determined above\n    {% endcomment %}\n\n    {% assign moves_in_groups = moves | reverse | in_groups_of: 250, fill_with: false %}\n\n    {% for move_group in moves_in_groups %}\n      {% action \"shopify\" %}\n        mutation {\n          collectionReorderProducts(\n            id: {{ collection.id | json }}\n            moves: {{ move_group | graphql_arguments }}\n          ) {\n            userErrors {\n              field\n              message\n            }\n          }\n        }\n      {% endaction %}\n    {% endfor %}\n  {% endif %}\n\n  {% assign new_cache_index = cache_index | plus: 1 %}\n\n  {% log\n    collections_seen: new_cache_index,\n    total_collections_to_sort: collection_ids_to_sort.size\n  %}\n\n  {% comment %}\n    -- process next collection in the cache if there is one\n  {% endcomment %}\n\n  {% if new_cache_index < collection_ids_to_sort.size %}\n    {% action \"event\" %}\n      {\n        \"topic\": \"user/collection_sort/process\",\n        \"task_id\": {{ task.id | json }},\n        \"data\": {\n          \"cache_key\": {{ cache_key | json }},\n          \"cache_index\": {{ new_cache_index }}\n        }\n      }\n    {% endaction %}\n\n  {% else %}\n    {% comment %}\n      -- use a distinct user event to indicate the entire task run is complete, so it can be filtered in the event log\n    {% endcomment %}\n\n    {% action \"event\" %}\n      {\n        \"topic\": \"user/collection_sort/complete\",\n        \"task_id\": {{ task.id | json }},\n        \"data\": {\n          \"cache_key\": {{ cache_key | json }},\n          \"cache_index\": {{ new_cache_index }}\n        }\n      }\n    {% endaction %}\n  {% endif %}\n\n{% elsif event.topic == \"user/collection_sort/complete\" %}\n  {% assign cache_key = event.data.cache_key %}\n  {% assign cache_index = event.data.cache_index %}\n\n  {% log\n    message: \"Collection sorting complete. Deleting cached collection IDs.\",\n    collections_seen: cache_index\n  %}\n\n  {% action \"cache\", \"del\", cache_key %}\n{% endif %}\n",
  "subscriptions": [
    "mechanic/user/trigger",
    "user/collection_sort/process",
    "user/collection_sort/complete"
  ],
  "subscriptions_template": "mechanic/user/trigger\nuser/collection_sort/process\nuser/collection_sort/complete\n{% if options.run_hourly__boolean %}\n  mechanic/scheduler/hourly\n{% elsif options.run_daily__boolean %}\n  mechanic/scheduler/daily\n{% endif %}",
  "tags": [
    "Collections",
    "Products",
    "Sort"
  ]
}
