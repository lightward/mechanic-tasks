{
  "docs": "This task runs daily to maintain tags for any customers that have a certain spending threshold within a rolling period of order history. Useful for rewarding customers who keep a consistent spend total. Select to have the rolling spend calculated using either \"Total sales\" (_net sales + additional fess + duties + shipping charges + taxes_) or only \"Net sales\" (_gross sales - discounts - returns_).\n\nOptionally, choose to filter by customers who have a specific tag, or to run hourly instead of daily for increased tagging frequency, or to run the task in \"Test mode\".\n\nThe \"Test mode\" option is highly recommended if you expect the task to make a lot of tagging changes (e.g. during initial set up), and you'd like to review the task run log of what it would do without making the actual tag updates. Just remember to turn off the test mode when you are ready for the daily (or hourly) scheduled task runs to make updates.",
  "halt_action_run_sequence_on_error": false,
  "name": "Auto-tag customers having a rolling minimum total spend",
  "online_store_javascript": null,
  "options": {
    "sales_calculation_to_use__choice_o1_total_sales_o2_net_sales_required": "total_sales",
    "minimum_total_spent__number_required": null,
    "customer_tag_to_apply__required": null,
    "days_of_order_history_to_consider__number_required": 30,
    "only_monitor_customers_having_this_tag": null,
    "run_hourly_instead_of_daily__boolean": null,
    "test_mode__boolean": false
  },
  "order_status_javascript": null,
  "perform_action_runs_in_sequence": false,
  "script": "{% assign sales_calculation_to_use = options.sales_calculation_to_use__choice_o1_total_sales_o2_net_sales_required %}\n{% assign minimum_total_spent = options.minimum_total_spent__number_required %}\n{% assign customer_tag_to_apply = options.customer_tag_to_apply__required %}\n{% assign days_of_order_history = options.days_of_order_history_to_consider__number_required %}\n{% assign monitor_customer_tag = options.only_monitor_customers_having_this_tag %}\n{% comment %}{{ options.run_hourly_instead_of_daily__boolean }}{% endcomment %}\n{% assign test_mode = options.test_mode__boolean %}\n\n{% if test_mode %}\n  {% comment %}\n    -- keep the write customers scope active in test mode, to avoid app updates\n  {% endcomment %}\n\n  {% permissions %}\n    write_customers\n  {% endpermissions %}\n{% endif %}\n\n{% if monitor_customer_tag == customer_tag_to_apply %}\n  {% error \"The two customer tag values must be different. Please change either 'Customer tag to apply' or 'Only monitor customers having this tag'.\" %}\n{% endif %}\n\n{% if event.topic == \"mechanic/user/trigger\" or event.topic contains \"mechanic/scheduler/\" %}\n  {% comment %}\n    -- get count of customers in the shop to use as upper limit in queries\n    -- support optional monitor tag\n  {% endcomment %}\n\n  {% assign monitor_tag_query = nil %}\n\n  {% if monitor_customer_tag != blank %}\n    {% assign monitor_tag_query = monitor_customer_tag | json | prepend: \"tag:\" %}\n  {% endif %}\n\n  {% capture query %}\n    query {\n      customersCount(\n        query: {{ monitor_tag_query | json }}\n        limit: null\n      ) {\n        count\n        precision\n      }\n    }\n  {% endcapture %}\n\n  {% assign result = query | shopify %}\n\n  {% if event.preview %}\n    {% capture result_json %}\n      {\n        \"data\": {\n          \"customersCount\": {\n            \"count\": 20000,\n            \"precision\": \"EXACT\"\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = result_json | parse_json %}\n  {% endif %}\n\n  {% assign customers_count = result.data.customersCount %}\n\n  {% log customers_count: customers_count %}\n\n  {% comment %}\n    -- use shopifyql query to get IDs of all customers who meet the minimum spend criteria and have not yet been tagged\n    -- support optional monitor tag\n  {% endcomment %}\n\n  {%- capture qualify_to_tag_shopifyql_query -%}\n    FROM sales\n    SHOW {{ sales_calculation_to_use }}, orders\n    WHERE customer_tags NOT CONTAINS '{{ customer_tag_to_apply }}'\n    {%- if monitor_customer_tag != blank %}\n    AND customer_tags CONTAINS '{{ monitor_customer_tag }}'\n    {%- endif %}\n    GROUP BY customer_email, customer_id\n    HAVING {{ sales_calculation_to_use }} >= {{ minimum_total_spent }}\n    SINCE -{{ days_of_order_history }}d UNTIL today\n    ORDER BY customer_id ASC\n    LIMIT {{ customers_count.count }}\n  {%- endcapture -%}\n\n  {% log qualify_to_tag_shopifyql_query %}\n\n  {% capture query %}\n    {\n      shopifyqlQuery(query: {{ qualify_to_tag_shopifyql_query | json }}) {\n        tableData {\n          rows\n        }\n        parseErrors\n      }\n    }\n  {% endcapture %}\n\n  {% assign result = query | shopify %}\n\n  {% if event.preview %}\n    {% capture result_json %}\n      {\n        \"data\": {\n          \"shopifyqlQuery\": {\n            \"tableData\": {\n              \"rows\": [\n                {\n                  \"customer_id\": \"1234567890\",\n                  \"customer_email\": \"sample@example.com\",\n                  \"total_sales\": {{ minimum_total_spent | json }}\n                }\n              ]\n            }\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = result_json | parse_json %}\n  {% endif %}\n\n  {% comment %}\n    -- shopify returns 0 for customer ID when the account is deleted, so exclude it\n  {% endcomment %}\n\n  {% assign customers_to_tag = array %}\n\n  {% for row in result.data.shopifyqlQuery.tableData.rows %}\n    {% unless row.customer_id == \"0\" %}\n      {% assign customers_to_tag = customers_to_tag | push: row %}\n    {% endunless %}\n  {% endfor %}\n\n  {% unless event.preview %}\n    {% log count_customers_to_tag: customers_to_tag.size %}\n    {% log customers_to_tag: customers_to_tag %}\n  {% endunless %}\n\n  {% comment %}\n    -- use shopifyql query to get IDs of all customers who meet the minimum spend criteria regardless of the tag to apply\n    -- support optional monitor tag\n  {% endcomment %}\n\n  {%- capture qualifying_shopifyql_query -%}\n    FROM sales\n    SHOW total_sales, orders\n    {%- if monitor_customer_tag != blank %}\n    WHERE customer_tags CONTAINS '{{ monitor_customer_tag }}'\n    {%- endif %}\n    GROUP BY customer_email, customer_id\n    HAVING total_sales >= {{ minimum_total_spent }}\n    SINCE -{{ days_of_order_history }}d UNTIL today\n    ORDER BY customer_id ASC\n    LIMIT {{ customers_count.count }}\n  {%- endcapture -%}\n\n  {% capture query %}\n    {\n      shopifyqlQuery(query: {{ qualifying_shopifyql_query | json }}) {\n        tableData {\n          rows\n        }\n        parseErrors\n      }\n    }\n  {% endcapture %}\n\n  {% assign result = query | shopify %}\n\n  {% if event.preview %}\n    {% capture result_json %}\n      {\n        \"data\": {\n          \"shopifyqlQuery\": {\n            \"tableData\": {\n              \"rows\": [\n                {\n                  \"customer_id\": \"1234567890\",\n                  \"customer_email\": \"sample@example.com\",\n                  \"total_sales\": {{ minimum_total_spent | json }}\n                }\n              ]\n            }\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = result_json | parse_json %}\n  {% endif %}\n\n  {% assign qualifying_customer_ids = result.data.shopifyqlQuery.tableData.rows | map: \"customer_id\" | except: \"0\" %}\n\n  {% unless event.preview %}\n    {% log count_qualifying_customers: qualifying_customer_ids.size %}\n    {% log qualifying_customer_ids: qualifying_customer_ids %}\n  {% endunless %}\n\n  {% comment %}\n    -- get IDs of all customers in the shop with the tag to apply\n    -- support optional monitor tag\n    -- analytics does not have data for customers with no orders in the rolling period, so we need to query the customers node\n  {% endcomment %}\n\n  {% if monitor_customer_tag == blank %}\n    {%- capture all_tagged_search_query -%}\n      tag:{{ customer_tag_to_apply | json }}\n    {%- endcapture -%}\n\n  {% else %}\n    {%- capture all_tagged_search_query -%}\n      tag:{{ customer_tag_to_apply | json }} AND tag:{{ monitor_customer_tag | json }}\n    {%- endcapture -%}\n  {% endif %}\n\n  {% assign loop_limit = customers_count.count | divided_by: 250.0 | ceil %}\n  {% assign cursor = nil %}\n  {% assign all_tagged_customer_ids = array %}\n\n  {% for n in (1..loop_limit) %}\n    {% capture query %}\n      query {\n        customers(\n          first: 250\n          after: {{ cursor | json }}\n          query: {{ all_tagged_search_query | json }}\n        ) {\n          pageInfo {\n            hasNextPage\n            endCursor\n          }\n          nodes {\n            legacyResourceId\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = query | shopify %}\n\n    {% if event.preview %}\n      {% capture result_json %}\n        {\n          \"data\": {\n            \"customers\": {\n              \"nodes\": [\n                {\n                  \"legacyResourceId\": \"3456789012\"\n                }\n              ]\n            }\n          }\n        }\n      {% endcapture %}\n\n      {% assign result = result_json | parse_json %}\n    {% endif %}\n\n    {% assign tagged_customer_ids = result.data.customers.nodes | map: \"legacyResourceId\" %}\n    {% assign all_tagged_customer_ids = all_tagged_customer_ids | concat: tagged_customer_ids %}\n\n    {% if result.data.customers.pageInfo.hasNextPage %}\n      {% assign cursor = result.data.customers.pageInfo.endCursor %}\n    {% else %}\n      {% break %}\n    {% endif %}\n  {% endfor %}\n\n  {% comment %}\n    -- identify customers to untag by confirming their ID is not in the qualifying customer IDs list\n  {% endcomment %}\n\n  {% assign customer_ids_to_untag = array %}\n\n  {% for customer_id in all_tagged_customer_ids %}\n    {% unless qualifying_customer_ids contains customer_id %}\n      {% assign customer_ids_to_untag = customer_ids_to_untag | push: customer_id %}\n    {% endunless %}\n  {% endfor %}\n\n  {% unless event.preview %}\n    {% log\n      all_tagged_search_query: all_tagged_search_query,\n      count_all_tagged_customers: all_tagged_customer_ids.size,\n      count_customers_to_untag: customer_ids_to_untag.size\n    %}\n    {% log customer_ids_to_untag: customer_ids_to_untag %}\n  {% endunless %}\n\n  {% if test_mode %}\n    {% log \"Test mode was enabled for this task run; no customer tag changes will be made.\" %}\n    {% break %}\n  {% endif %}\n\n  {% for customer in customers_to_tag %}\n    {% action \"shopify\" %}\n      mutation {\n        tagsAdd(\n          id: {{ customer.customer_id | prepend: \"gid://shopify/Customer/\" | json }}\n          tags: {{ customer_tag_to_apply | json }}\n        ) {\n          userErrors {\n            field\n            message\n          }\n        }\n      }\n    {% endaction %}\n  {% endfor %}\n\n  {% for customer_id in customer_ids_to_untag %}\n    {% action \"shopify\" %}\n      mutation {\n        tagsRemove(\n          id: {{ customer_id | prepend: \"gid://shopify/Customer/\" | json }}\n          tags: {{ customer_tag_to_apply | json }}\n        ) {\n          userErrors {\n            field\n            message\n          }\n        }\n      }\n    {% endaction %}\n  {% endfor %}\n{% endif %}\n",
  "subscriptions": [
    "mechanic/scheduler/daily",
    "mechanic/user/trigger"
  ],
  "subscriptions_template": "{% if options.run_hourly_instead_of_daily__boolean %}\n  mechanic/scheduler/hourly\n{% else %}\n  mechanic/scheduler/daily\n{% endif %}\nmechanic/user/trigger",
  "tags": [
    "Auto-Tag",
    "Customers",
    "Spend"
  ]
}
