{
  "docs": "Automatically send out an email to your customers when a tag is added to their account. Useful for sending approval emails, welcome emails if the customer was created with a certain tag, or any other emails related to an update to the customer's status. The most common use of this task is to send out emails to customers when their accounts are approved, but you can use this task to email customers any kind of alert you like, triggered by a simple tag. For example, some themes include an email subscription form that creates a customer record, pre-tagged with \"email subscribe\", or something to that effect.\n\n**Important note:** After saving this task for the first time (and every time you change the tag to watch for), click the \"Run task\" button. Mechanic will then scan your customers to find those who _already_ have the desired tag, and will make a note of them, so as to not email them in the future. (We require this to avoid suddenly sending a flood of emails to customers that were tagged before the Mechanic task was created.)\n\nEnable the \"Autotag customers after emailing\" option to have Mechanic add \"YOURTAGHERE-email-sent\" to the customer's tags, when their email is sent out.",
  "halt_action_run_sequence_on_error": false,
  "name": "Email customers when tagged",
  "online_store_javascript": null,
  "options": {
    "tag_to_watch_for__required": "approved",
    "ignore_tag_case__boolean": true,
    "email_subject__required": "Your account has been approved!",
    "email_body__required_multiline": "Hi {{ customer.first_name | default: \"there\" }},\n\nYour account for {{ shop.name }} has been approved! Thanks for registering, and we'll see you soon.\n\nThanks,\nThe team at {{ shop.name }}",
    "autotag_customers_after_emailing__boolean": null
  },
  "order_status_javascript": null,
  "perform_action_runs_in_sequence": false,
  "script": "{% assign approval_tag = options.tag_to_watch_for__required %}\n\n{% if options.ignore_tag_case__boolean %}\n  {% assign approval_tag = options.tag_to_watch_for__required | downcase %}\n{% endif %}\n\n{% capture email_sent_tag %}{{ approval_tag }}-email-sent{% endcapture %}\n{% assign tag_processed_metafield_key = task.created_at | date: \"%s\" | append: approval_tag | append: \"tag-processed\" | sha256 | slice: 0, 5 | prepend: \"-\" | prepend: approval_tag %}\n{% assign customers_scanned_metafield_key = task.created_at | date: \"%s\" | append: approval_tag | append: \"customers-scanned\" | sha256 | slice: 0, 5 | prepend: \"-\" | prepend: approval_tag %}\n\n{% if event.topic contains \"shopify/customers/\" %}\n  {% assign customer_tags = customer.tags | split: \", \" %}\n\n  {% if options.ignore_tag_case__boolean %}\n    {% assign customer_tags = customer.tags | downcase | split: \", \" %}\n  {% endif %}\n\n  {% assign customer_qualifies = true %}\n  {% unless customer_tags contains approval_tag %}\n    {% assign customer_qualifies = false %}\n    {% log \"The customer does not have the required tag.\" %}\n  {% endunless %}\n\n  {% if options.autotag_customers_after_emailing__boolean %}\n    {% if customer_tags contains email_sent_tag %}\n      {% assign customer_qualifies = false %}\n      {% log \"According to the customer's tags, this customer has already received this email.\" %}\n    {% endif %}\n  {% endif %}\n\n  {% if customer_qualifies %}\n    {% capture query %}\n      query {\n        customer(id: {{ customer.admin_graphql_api_id | json }}) {\n          metafield(namespace: \"mechanic\", key: {{ tag_processed_metafield_key | json }}) {\n            value\n          }\n        }\n      }\n    {% endcapture %}\n    {% assign result = query | shopify %}\n\n    {% if event.preview %}\n      {% capture result_json %}\n        {\n          \"data\": {\n            \"customer\": {\n              \"metafield\": {\n                \"value\": \"1\"\n              }\n            }\n          }\n        }\n      {% endcapture %}\n      {% assign result = result_json | parse_json %}\n    {% endif %}\n\n    {% if result.data.customer.metafield %}\n      {% assign customer_qualifies = false %}\n      {% log \"According to a stored metafield, this customer has already received this email, or was already tagged when this task was initially set up.\" %}\n    {% endif %}\n  {% endif %}\n\n  {% if customer_qualifies %}\n    {% capture query %}\n      query {\n        shop {\n          metafield(namespace: \"mechanic\", key: {{ customers_scanned_metafield_key | json }}) {\n            value\n          }\n        }\n      }\n    {% endcapture %}\n    {% assign result = query | shopify %}\n\n    {% if event.preview %}\n      {% capture result_json %}\n        {\n          \"data\": {\n            \"shop\": {\n              \"metafield\": {\n                \"value\": \"1\"\n              }\n            }\n          }\n        }\n      {% endcapture %}\n      {% assign result = result_json | parse_json %}\n    {% endif %}\n\n    {% if result.data.shop.metafield == nil %}\n      {% error \"Please use this task's 'Run task' button to manually scan your existing customers. Mechanic will take note of everyone who's already tagged, so as to *not* send them an email in the future.\" %}\n    {% endif %}\n  {% endif %}\n\n  {% if event.preview or customer_qualifies %}\n    {% action \"email\" %}\n      {\n        \"to\": {{ customer.email | json }},\n        \"subject\": {{ options.email_subject__required | json }},\n        \"body\": {{ options.email_body__required_multiline | strip | newline_to_br | json }},\n        \"reply_to\": {{ shop.customer_email | json }},\n        \"from_display_name\": {{ shop.name | json }}\n      }\n    {% endaction %}\n\n    {% action \"shopify\" %}\n      mutation {\n        {% if options.autotag_customers_after_emailing__boolean %}\n          tagsAdd(\n            id: {{ customer.admin_graphql_api_id | json }}\n            tags: {{ email_sent_tag | json }}\n          ) {\n            userErrors {\n              field\n              message\n            }\n          }\n        {% endif %}\n\n        customerUpdate(input: {\n          id: {{ customer.admin_graphql_api_id | json }}\n          metafields: [\n            {\n              namespace: \"mechanic\"\n              key: {{ tag_processed_metafield_key | json }}\n              type: \"number_integer\"\n              value: \"1\"\n            }\n          ]\n        }) {\n          userErrors {\n            field\n            message\n          }\n        }\n      }\n    {% endaction %}\n  {% endif %}\n\n{% elsif event.topic == \"mechanic/user/trigger\" %}\n  {% assign metafield_inputs = array %}\n  {% assign cursor = nil %}\n\n  {% for n in (0..100) %}\n    {% capture query %}\n      query {\n        customerSegmentMembers(\n          first: 1000\n          query: \"customer_tags CONTAINS '{{ approval_tag }}'\"\n          after: {{ cursor | json }}\n        ) {\n          pageInfo {\n            hasNextPage\n            endCursor\n          }\n          edges {\n            node {\n              id\n              metafield(\n                namespace: \"mechanic\"\n                key: {{ tag_processed_metafield_key | json }}\n              ) {\n                value\n              }\n            }\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = query | shopify %}\n\n    {% if event.preview %}\n      {% capture result_json %}\n        {\n          \"data\": {\n            \"customerSegmentMembers\": {\n              \"edges\": [\n                {\n                  \"node\": {\n                    \"id\": \"gid://shopify/CustomerSegmentMember/1234567890\",\n                    \"metafield\": null\n                  }\n                }\n              ]\n            }\n          }\n        }\n      {% endcapture %}\n\n      {% assign result = result_json | parse_json %}\n    {% endif %}\n\n    {% assign customers = result.data.customerSegmentMembers.edges | map: \"node\" %}\n\n    {% comment %}\n      -- Note: Shopify API accepts CustomerSegmentMember IDs without needing replacement, at least for the metafieldsSet mutation\n    {% endcomment %}\n\n    {% for customer in customers %}\n      {% if customer.metafield == blank %}\n        {% assign metafield_input = hash %}\n        {% assign metafield_input[\"ownerId\"] = customer.id %}\n        {% assign metafield_input[\"namespace\"] = \"mechanic\" %}\n        {% assign metafield_input[\"key\"] = tag_processed_metafield_key %}\n        {% assign metafield_input[\"type\"] = \"number_integer\" %}\n        {% assign metafield_input[\"value\"] = \"1\" %}\n        {% assign metafield_inputs = metafield_inputs | push: metafield_input %}\n      {% endif %}\n    {% endfor %}\n\n    {% if result.data.customerSegmentMembers.pageInfo.hasNextPage %}\n      {% assign cursor = result.data.customerSegmentMembers.pageInfo.endCursor %}\n    {% else %}\n      {% break %}\n    {% endif %}\n  {% endfor %}\n\n  {% if metafield_inputs != blank %}\n    {% assign groups_of_metafield_inputs = metafield_inputs | in_groups_of: 25, fill_with: false %}\n\n    {% for group_of_metafield_inputs in groups_of_metafield_inputs %}\n      {% action \"shopify\" %}\n        mutation {\n          metafieldsSet(\n            metafields: {{ group_of_metafield_inputs | graphql_arguments }}\n          ) {\n            metafields {\n              id\n              namespace\n              key\n              type\n              value\n              owner {\n                ... on Customer {\n                  id\n                }\n              }\n            }\n            userErrors {\n              code\n              field\n              message\n            }\n          }\n        }\n      {% endaction %}\n    {% endfor %}\n  {% endif %}\n\n  {% action \"shopify\" %}\n    mutation {\n      metafieldsSet(\n        metafields: [\n          {\n            ownerId: {{ \"gid://shopify/Shop/\" | append: shop.id | json }}\n            namespace: \"mechanic\"\n            key: {{ customers_scanned_metafield_key | json }}\n            type: \"number_integer\"\n            value: \"1\"\n          }\n        ]\n      ) {\n        metafields {\n          id\n          namespace\n          key\n          type\n          value\n          owner {\n            ... on Shop {\n              id\n            }\n          }\n        }\n        userErrors {\n          code\n          field\n          message\n        }\n      }\n    }\n  {% endaction %}\n{% endif %}\n",
  "subscriptions": [
    "shopify/customers/create",
    "shopify/customers/update",
    "mechanic/user/trigger"
  ],
  "subscriptions_template": "shopify/customers/create\nshopify/customers/update\nmechanic/user/trigger",
  "tags": [
    "Customers",
    "Email",
    "Tag",
    "Watch"
  ]
}
