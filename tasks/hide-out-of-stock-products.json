{
  "docs": "This task monitors inventory updates, and pulls the product from the configured sales channels whenever a product's total inventory meets your \"out of stock\" threshold. Optionally, it'll send you an email when it does so. You may also choose whether to further refine the products being considered by this task by configuring inclusion or exclusion tags (note: exclusion tags will always take precedence over inclusion tags).\n\nIf you'd like for the task to only count inventory from specific locations, then add the _exact_ location names into the task configuration. This feature can be combined with the tag options for unique unpublishing scenarios.\n\nThis task can also be run manually, to scan all products in the shop.",
  "halt_action_run_sequence_on_error": false,
  "name": "Hide out-of-stock products",
  "online_store_javascript": null,
  "options": {
    "out_of_stock_inventory_quantity__number_required": "0",
    "sales_channel_names__required_array": ["Online Store"],
    "only_include_products_with_any_of_these_tags__array": null,
    "always_exclude_products_with_any_of_these_tags__array": null,
    "only_include_inventory_from_these_location_names__array": null,
    "email_notification_recipient__email": null
  },
  "order_status_javascript": null,
  "perform_action_runs_in_sequence": false,
  "script": "{% assign out_of_stock_inventory_quantity = options.out_of_stock_inventory_quantity__number_required %}\n{% assign sales_channel_names = options.sales_channel_names__required_array %}\n{% assign inclusion_tags = options.only_include_products_with_any_of_these_tags__array %}\n{% assign exclusion_tags = options.always_exclude_products_with_any_of_these_tags__array %}\n{% assign location_names = options.only_include_inventory_from_these_location_names__array %}\n{% assign email_notification_recipient = options.email_notification_recipient__email %}\n\n{% comment %}\n  -- get all of the sales channels in the shop; no known sales channel limit, so just use query max of 250\n  -- NOTE: publication name is deprecated (as of Apil 2023), but the Shopify offered solution of using the catalog title currently returns null\n{% endcomment %}\n\n{% capture query %}\n  query {\n    publications(first: 250) {\n      nodes {\n        id\n        name\n      }\n    }\n  }\n{% endcapture %}\n\n{% assign result = query | shopify %}\n\n{% if event.preview %}\n  {% capture result_json %}\n    {\n      \"data\": {\n        \"publications\": {\n          \"nodes\": [\n            {\n              \"id\": \"gid://shopify/Publication/1234567890\",\n              \"name\": {{ sales_channel_names.first | json }}\n            }\n          ]\n        }\n      }\n    }\n  {% endcapture %}\n\n  {% assign result = result_json | parse_json %}\n{% endif %}\n\n{% assign publication_ids = array %}\n{% assign publication_names_by_id = hash %}\n\n{% comment %}\n  -- add the configured publication names into a hash for use in lookups\n{% endcomment %}\n\n{% for publication in result.data.publications.nodes %}\n  {% if sales_channel_names contains publication.name %}\n    {% assign publication_ids[publication_ids.size] = publication.id %}\n    {% assign publication_names_by_id[publication.id] = publication.name %}\n  {% endif %}\n{% endfor %}\n\n{% comment %}\n  -- make sure the configured sales channel names match what is in the shop\n{% endcomment %}\n\n{% unless event.preview %}\n  {% assign available_channels = result.data.publications.nodes | map: \"name\" %}\n\n  {% if publication_ids.size != sales_channel_names.size %}\n    {% error\n      message: \"Each sales channel configured in this task must exist in the shop. Check the list of available channels and verify each configured channel exists.\",\n      available_sales_channel_names: available_channels,\n      configured_sales_channel_names: sales_channel_names\n    %}\n\n    {% break %}\n  {% endif %}\n{% endunless %}\n\n{% if location_names != blank %}\n  {% comment %}\n    -- get all of the locations in the shop; Shopify supports 1000 as of July 2023\n  {% endcomment %}\n\n  {% assign cursor = nil %}\n  {% assign locations = array %}\n\n  {% for n in (1..10) %}\n    {% capture query %}\n      query {\n        locations(\n          first: 250\n          after: {{ cursor | json }}\n          sortKey: NAME\n        ) {\n          pageInfo {\n            hasNextPage\n            endCursor\n          }\n          nodes {\n            id\n            name\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = query | shopify %}\n\n    {% if event.preview %}\n      {% capture result_json %}\n        {\n          \"data\": {\n            \"locations\": {\n              \"nodes\": [\n                {\n                  \"id\": \"gid://shopify/Location/1234567890\",\n                  \"name\": {{ location_names.first | json }}\n                }\n              ]\n            }\n          }\n        }\n      {% endcapture %}\n\n      {% assign result = result_json | parse_json %}\n    {% endif %}\n\n    {% assign locations = locations | concat: result.data.locations.nodes %}\n\n    {% if result.data.locations.pageInfo.hasNextPage %}\n      {% assign cursor = result.data.locations.pageInfo.endCursor %}\n    {% else %}\n      {% break %}\n    {% endif %}\n  {% endfor %}\n\n  {% assign location_ids = array %}\n\n  {% comment %}\n    -- save the location IDs that map to the configured location names\n  {% endcomment %}\n\n  {% for location in locations %}\n    {% if location_names contains location.name %}\n      {% assign location_ids[location_ids.size] = location.id %}\n    {% endif %}\n  {% endfor %}\n\n  {% comment %}\n    -- make sure the configured location names match what is in the shop\n  {% endcomment %}\n\n  {% unless event.preview %}\n    {% if location_ids.size != location_names.size %}\n      {% assign available_location_names = locations | map: \"name\" %}\n\n      {% error\n        message: \"Each location name configured in this task must exactly match a location name in the shop. Check the list of available locations and verify each configured location exists.\",\n        available_location_names: available_location_names,\n        configured_location_names: location_names\n      %}\n\n      {% break %}\n    {% endif %}\n  {% endunless %}\n{% endif %}\n\n{% if event.topic == \"mechanic/user/trigger\" %}\n  {% comment %}\n    -- use an inventory filter in the products search query only if no location names have been configured in the task\n  {% endcomment %}\n\n  {% if location_names == blank %}\n    {% assign inventory_filter = out_of_stock_inventory_quantity | prepend: \"inventory_total:<=\" %}\n  {% endif %}\n\n  {% comment %}\n    -- if inclusion or exclusion tags are configured, use them to refine the search query in order to reduce the number of products to be processed\n  {% endcomment %}\n\n  {% if inclusion_tags != blank %}\n    {% assign inclusion_tag_filters = array %}\n\n    {% for inclusion_tag in inclusion_tags %}\n      {% assign inclusion_tag_filter\n        = inclusion_tag\n        | json\n        | prepend: \"tag:\"\n      %}\n      {% assign inclusion_tag_filters = inclusion_tag_filters | push: inclusion_tag_filter %}\n    {% endfor %}\n\n    {% if inclusion_tag_filters.size > 1 %}\n      {% capture inclusion_tag_filters -%}\n        ({{ inclusion_tag_filters | join: \" OR \" }})\n      {%- endcapture %}\n    {% endif %}\n  {% endif %}\n\n  {% if exclusion_tags != blank %}\n    {% assign exclusion_tag_filters = array %}\n\n    {% for exclusion_tag in exclusion_tags %}\n      {% assign exclusion_tag_filter\n        = exclusion_tag\n        | json\n        | prepend: \"tag_not:\"\n      %}\n      {% assign exclusion_tag_filters = exclusion_tag_filters | push: exclusion_tag_filter %}\n    {% endfor %}\n\n    {% if exclusion_tag_filters.size > 1 %}\n      {% capture exclusion_tag_filters -%}\n        {{ exclusion_tag_filters | join: \" AND \" }}\n      {%- endcapture %}\n    {% endif %}\n  {% endif %}\n\n  {% comment %}\n    -- recombine any search filters for use in the products query\n  {% endcomment %}\n\n  {% assign search_query\n    = array\n    | push: inventory_filter, inclusion_tag_filters, exclusion_tag_filters\n    | compact\n    | join: \" AND \"\n  %}\n\n  {% log products_search_query: search_query %}\n\n  {% comment %}\n    -- use paginated query to get all products in the shop that match the optional search filters\n  {% endcomment %}\n\n  {% assign products = array %}\n  {% assign cursor = nil %}\n\n  {% for n in (0..100) %}\n    {% capture query %}\n      query {\n        products(\n          first: 250\n          after: {{ cursor | json }}\n          query: {{ search_query | json }}\n        ) {\n          pageInfo {\n            hasNextPage\n            endCursor\n          }\n          nodes {\n            id\n            legacyResourceId\n            title\n            totalInventory\n            tags\n            {% for publication_id in publication_ids %}\n              published{{ forloop.index }}: publishedOnPublication(publicationId: {{ publication_id | json }})\n            {% endfor %}\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = query | shopify %}\n\n    {% if event.preview %}\n      {% capture result_json %}\n        {\n          \"data\": {\n            \"products\": {\n              \"nodes\": [\n                {\n                  \"id\": \"gid://shopify/Product/1234567890\",\n                  \"legacyResourceId\": \"1234567890\",\n                  \"title\": \"Widget\",\n                  \"totalInventory\": 0,\n                  \"published1\": true\n                }\n              ]\n            }\n          }\n        }\n      {% endcapture %}\n\n      {% assign result = result_json | parse_json %}\n    {% endif %}\n\n    {% assign products = products | concat: result.data.products.nodes %}\n\n    {% if result.data.products.pageInfo.hasNextPage %}\n      {% assign cursor = result.data.products.pageInfo.endCursor %}\n    {% else %}\n      {% break %}\n    {% endif %}\n  {% endfor %}\n\n{% elsif event.topic contains \"shopify/inventory_levels/\" %}\n  {% comment %}\n    -- query the inventory level to get the product data needed for this task\n  {% endcomment %}\n\n  {% capture query %}\n    query {\n      inventoryLevel(\n        id: {{ inventory_level.admin_graphql_api_id | json }}\n      ) {\n        item {\n          variant {\n            product {\n              id\n              legacyResourceId\n              title\n              totalInventory\n              tags\n              {% for publication_id in publication_ids %}\n                published{{ forloop.index }}: publishedOnPublication(publicationId: {{ publication_id | json }})\n              {% endfor %}\n            }\n          }\n        }\n      }\n    }\n  {% endcapture %}\n\n  {% assign result = query | shopify %}\n\n  {% if event.preview %}\n    {% capture result_json %}\n      {\n        \"data\": {\n          \"inventoryLevel\": {\n            \"item\": {\n              \"variant\": {\n                \"product\": {\n                  \"id\": \"gid://shopify/Product/1234567890\",\n                  \"legacyResourceId\": \"1234567890\",\n                  \"title\": \"Widget\",\n                  \"totalInventory\": 0,\n                  \"tags\": {{ inclusion_tags.first | json }},\n                  \"published1\": true\n                }\n              }\n            }\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = result_json | parse_json %}\n  {% endif %}\n\n  {% assign product = result.data.inventoryLevel.item.variant.product %}\n\n  {% comment %}\n    -- check to see if product is included or excluded (i.e. whether to process) by any configured tags\n  {% endcomment %}\n\n  {% assign product_included_by_tag = nil %}\n  {% assign product_excluded_by_tag = nil %}\n\n  {% if inclusion_tags != blank %}\n    {% for inclusion_tag in inclusion_tags %}\n      {% if product.tags contains inclusion_tag %}\n        {% assign product_included_by_tag = true %}\n      {% endif %}\n    {% endfor %}\n  {% endif %}\n\n  {% if exclusion_tags != blank %}\n    {% for exclusion_tag in exclusion_tags %}\n      {% if product.tags contains exclusion_tag %}\n        {% assign product_excluded_by_tag = true %}\n      {% endif %}\n    {% endfor %}\n  {% endif %}\n\n  {% comment %}\n    -- check if a product has been excluded first, then only if there are inclusion tags configured check if it has been included\n  {% endcomment %}\n\n  {% if product_excluded_by_tag %}\n    {% log\n      message: \"Product was excluded by a configured tag and will not be processed by this task.\",\n      exclusion_tags: exclusion_tags,\n      product: product\n    %}\n    {% break %}\n\n  {% elsif inclusion_tags != blank %}\n    {% unless product_included_by_tag %}\n      {% log\n        message: \"Product was not included by any configured tag and will not be processed by this task.\",\n        inclusion_tags: inclusion_tags,\n        product: product\n      %}\n      {% break %}\n    {% endunless %}\n  {% endif %}\n\n  {% comment %}\n    -- product qualifies to be processed in main product loop\n  {% endcomment %}\n\n  {% assign products = array | push: product %}\n{% endif %}\n\n{% comment %}\n  -- process products, unpublishing as needed and saving links for optional email output\n{% endcomment %}\n\n{% assign unpublished_product_links = array %}\n\n{% for product in products %}\n  {% assign mutations = array %}\n  {% assign publication_names = array %}\n\n  {% if location_names == blank %}\n    {% comment %}\n      -- any products returned in the query will have met the out of stock quantity threshold due to the search filter, so can just output the total inventory\n    {% endcomment %}\n\n    {% assign summed_inventory = product.totalInventory %}\n\n  {% else %}\n    {% assign summed_inventory = 0 %}\n\n    {% comment %}\n      -- query and sum available inventory across the configured locations to determine stock status\n      -- to avoid exceeding api query cost, first get the inventory item IDs\n    {% endcomment %}\n\n    {% capture query %}\n      query {\n        product(id: {{ product.id | json }}) {\n          id\n          variants(first: 100) {\n            nodes {\n              inventoryItem {\n                id\n              }\n            }\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = query | shopify %}\n\n    {% if event.preview %}\n      {% capture result_json %}\n        {\n          \"data\": {\n            \"product\": {\n              \"id\": \"gid://shopify/Product/1234567890\",\n              \"variants\": {\n                \"nodes\": [\n                  {\n                    \"inventoryItem\": {\n                      \"id\": \"gid://shopify/InventoryItem/1234567890\"\n                    }\n                  }\n                ]\n              }\n            }\n          }\n        }\n      {% endcapture %}\n\n      {% assign result = result_json | parse_json %}\n    {% endif %}\n\n    {% assign inventory_item_ids\n      = result.data.product.variants.nodes\n      | map: \"inventoryItem\"\n      | map: \"id\"\n    %}\n\n    {% comment %}\n      -- loop through inventory items and get available quantity for each configured location\n    {% endcomment %}\n\n    {% for inventory_item_id in inventory_item_ids %}\n      {% capture query %}\n        query {\n          inventoryItem(id: {{ inventory_item_id | json }}) {\n            {% for location_id in location_ids %}\n              inventory_level_{{ forloop.index }}: inventoryLevel(locationId: {{ location_id | json }}) {\n                quantities(names: \"available\") {\n                  quantity\n                }\n              }\n            {% endfor %}\n          }\n        }\n      {% endcapture %}\n\n      {% assign result = query | shopify %}\n\n      {% if event.preview %}\n        {% capture result_json %}\n          {\n            \"data\": {\n              \"inventoryItem\": {\n                \"inventory_level_1\": {\n                  \"quantities\": [\n                    {\n                      \"quantity\": 0\n                    }\n                  ]\n                },\n                \"inventory_level_2\": null\n              }\n            }\n          }\n        {% endcapture %}\n\n        {% assign result = result_json | parse_json %}\n      {% endif %}\n\n      {% for item in result.data.inventoryItem %}\n        {% assign summed_inventory = summed_inventory | plus: item[1].quantities.first.quantity %}\n      {% endfor %}\n    {% endfor %}\n  {% endif %}\n\n  {% if summed_inventory > out_of_stock_inventory_quantity %}\n    {% comment %}\n      -- the summed inventory across the configured locations is greater than the out of stock threshold; skip this product\n    {% endcomment %}\n\n    {% continue %}\n  {% endif %}\n\n  {% comment %}\n    -- capture unpublish mutation for each sales channel a product is published on\n  {% endcomment %}\n\n  {% for publication_id in publication_ids %}\n    {% assign key = \"published\" | append: forloop.index %}\n\n    {% if product[key] == false %}\n      {% continue %}\n    {% endif %}\n\n    {% assign publication_names[publication_names.size] = publication_names_by_id[publication_id] %}\n\n    {% capture mutation %}\n      publishableUnpublish{{ forloop.index}}: publishableUnpublish(\n        id: {{ product.id | json }}\n        input: {\n          publicationId: {{ publication_id | json }}\n        }\n      ) {\n        userErrors {\n          field\n          message\n        }\n      }\n    {% endcapture %}\n\n    {% assign mutations[mutations.size] = mutation %}\n  {% endfor %}\n\n  {% comment %}\n    -- if there are any unpublishing actions to take, then do so and generate a notification email if a recipient is configured\n  {% endcomment %}\n\n  {% if mutations != empty %}\n    {% action \"shopify\" %}\n      mutation {\n        {{ mutations | join: newline }}\n      }\n    {% endaction %}\n\n    {% comment %}\n      -- if this task was triggered by an inventory level event, then send email right away; otherwise save admin links for each product that was unpublished\n    {% endcomment %}\n\n    {% if event.topic contains \"shopify/inventory_levels/\" %}\n      {% if email_notification_recipient != blank %}\n        {% capture email_subject %}\n          Out of stock: {{ product.title }}\n        {% endcapture %}\n\n        {% capture email_body %}\n          Hi there,\n\n          Your product is out of stock{% if location_names != blank %} at the configured locations{% else %} across all locations{% endif %}! This product has been unpublished from: {{ publication_names | join: \", \" }}.\n\n          <a href=\"https://{{ shop.domain }}/admin/products/{{ product.legacyResourceId }}\">Manage this product</a>\n\n          Thanks,\n          - Mechanic, for {{ shop.name }}\n        {% endcapture %}\n\n        {% action \"email\" %}\n          {\n            \"to\": {{ email_notification_recipient | json }},\n            \"subject\": {{ email_subject | unindent | strip | json }},\n            \"body\": {{ email_body | unindent | strip | newline_to_br | json }}\n          }\n        {% endaction %}\n      {% endif %}\n\n    {% else %}\n      {% capture link -%}\n        <li><a href=\"https://{{ shop.domain }}/admin/products/{{ product.legacyResourceId }}\">{{ product.title }}</a> ({{ summed_inventory }} - unpublished from {{ publication_names | join: \", \" }})</li>\n      {%- endcapture %}\n\n      {% assign unpublished_product_links[unpublished_product_links.size] = link %}\n    {% endif %}\n  {% endif %}\n{% endfor %}\n\n{% comment %}\n  -- for manually triggered task runs, send notification email if any unpublishing actions were taken AND if there is an email notification recipient configured\n{% endcomment %}\n\n{% if unpublished_product_links == blank %}\n  {% unless event.topic contains \"shopify/inventory_levels\" %}\n    {% log \"No products qualified to be unpublished during this task run.\" %}\n  {% endunless %}\n\n  {% break %}\n{% endif %}\n\n{% if email_notification_recipient != blank %}\n  {% capture email_subject %}\n    Found {{ unpublished_product_links.size }} {{ unpublished_product_links.size | pluralize: \"product\", \"products\" }} out of stock\n  {% endcapture %}\n\n  {% capture email_body %}\n    Hi there,\n    <br><br>\n    These products were found to be at or below your out of stock minimum quantity ({{ out_of_stock_inventory_quantity }}), when adding up the inventory for each product{% if location_names != blank %} at the configured locations{% else %} across all locations{% endif %}.\n    <br>\n    <ul>{{ unpublished_product_links | join: \"\" }}</ul>\n    <br>\n    Thanks,\n    <br>\n    - Mechanic, for {{ shop.name }}\n  {% endcapture %}\n\n  {% action \"email\" %}\n    {\n      \"to\": {{ email_notification_recipient | json }},\n      \"subject\": {{ email_subject | unindent | strip | json }},\n      \"body\": {{ email_body | unindent | strip | json }}\n    }\n  {% endaction %}\n{% endif %}\n",
  "subscriptions": ["mechanic/user/trigger", "shopify/inventory_levels/update"],
  "subscriptions_template": "mechanic/user/trigger\nshopify/inventory_levels/update",
  "tags": ["Inventory", "Location", "Out of Stock", "Products", "Unpublish"]
}
