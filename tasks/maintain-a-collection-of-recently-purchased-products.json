{
  "name": "Maintain a collection of recently purchased products",
  "options": {
    "collection_maximum_size__number_required": null,
    "collection_id__number_required": null,
    "ignore_products_that_are_sold_out__boolean": null,
    "wait_until_order_is_fulfilled__boolean": null
  },
  "subscriptions": [
    "shopify/orders/paid"
  ],
  "subscriptions_template": "{% if options.wait_until_order_is_fulfilled__boolean %}\n  shopify/orders/fulfilled\n{% else %}\n  shopify/orders/paid\n{% endif %}",
  "script": "{% comment %}\n  This task script *also* includes a feature for ignoring\n  products based on metafield value. To reveal and use this\n  feature, swap \"options_\" for \"options.\" in these variables:\n  * options_product_metafield_namespace\n  * options_product_metafield_key\n  * options_ignore_products_having_this_metafield_value\n{% endcomment %}\n\n{% assign collection_maximum_size = options.collection_maximum_size__number_required %}\n{% assign collection = shop.collections[options.collection_id__number_required] %}\n\n{% if collection_maximum_size < 1 %}\n  {% error \"The 'Collection maximum size' option must be at least 1. :)\" %}\n{% else %}\n  {% assign collection_maximum_size_rounded = collection_maximum_size | round %}\n  {% if collection_maximum_size_rounded != collection_maximum_size %}\n    {% error \"The 'Collection maximum size' option must be a whole number. ;)\" %}\n  {% endif %}\n{% endif %}\n\n{% if event.preview %}\n  {% assign order = hash %}\n  {% assign order = \"gid://shopify/Order/1234567890\" %}\n\n  {% assign collection = hash %}\n  {% assign collection[\"admin_graphql_api_id\"] = \"gid://shopify/Collection/1234567890\" %}\n{% endif %}\n\n{% assign product_ids_ordered = array %}\n{% assign cursor = nil %}\n\n{% for n in (0..100) %}\n  {% capture query %}\n    query {\n      order(id: {{ order.admin_graphql_api_id | json }}) {\n        id\n        lineItems(\n          first: 250\n          after: {{ cursor | json }}\n        ) {\n          edges {\n            node {\n              product {\n                id\n                {% if options.ignore_products_that_are_sold_out__boolean %}\n                  totalInventory\n                {% endif %}\n                {% if options_product_metafield_namespace != blank %}\n                  metafield(\n                    namespace: {{ options_product_metafield_namespace | json }}\n                    key: {{ options_product_metafield_key | json }}\n                  ) {\n                    value\n                  }\n                {% endif %}\n              }\n            }\n          }\n        }\n      }\n    }\n  {% endcapture %}\n\n  {% assign result = query | shopify %}\n\n  {% if event.preview %}\n    {% capture result_json %}\n      {\n        \"data\": {\n          \"order\": {\n            \"id\": \"gid://shopify/Order/1234567890\",\n            \"lineItems\": {\n              \"edges\": [\n                {\n                  \"node\": {\n                    \"product\": {\n                      {% if options.ignore_products_that_are_sold_out__boolean %}\n                        \"totalInventory\": 1,\n                      {% endif %}\n                      {% if options_product_metafield_namespace != blank %}\n                        \"metafield\": null,\n                      {% endif %}\n                      \"id\": \"gid://shopify/Product/1234567890\"\n                    }\n                  }\n                },\n                {\n                  \"node\": {\n                    {% comment %}\n                      Prove that line items having no product are ignored\n                    {% endcomment %}\n                    \"product\": null\n                  }\n                }\n              ]\n            }\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = result_json | parse_json %}\n  {% endif %}\n\n  {% for lineItem_edge in result.data.order.lineItems.edges %}\n    {% assign product = lineItem_edge.node.product %}\n    {% if product == nil %}\n      {% continue %}\n    {% endif %}\n\n    {% if options.ignore_products_that_are_sold_out__boolean and product.totalInventory <= 0 %}\n      {% continue %}\n    {% elsif options_product_metafield_namespace != blank and product.metafield.value == options_ignore_products_having_this_metafield_value %}\n        {% continue %}\n    {% endif %}\n\n    {% assign product_ids_ordered[product_ids_ordered.size] = product.id %}\n  {% endfor %}\n\n  {% if result.data.order.lineItems.pageInfo.hasNextPage %}\n    {% assign cursor = result.data.order.lineItems.edges.last.cursor %}\n  {% else %}\n    {% break %}\n  {% endif %}\n{% endfor %}\n\n{% assign product_ids_already_collected = array %}\n{% assign cursor = nil %}\n\n{% for n in (0..100) %}\n  {% capture query %}\n    query {\n      collection(id: {{ collection.admin_graphql_api_id | json }}) {\n        products(\n          first: 250\n          after: {{ cursor | json }}\n        ) {\n          pageInfo {\n            hasNextPage\n          }\n          edges {\n            cursor\n            node {\n              id\n            }\n          }\n        }\n      }\n    }\n  {% endcapture %}\n\n  {% assign result = query | shopify %}\n\n  {% if event.preview %}\n    {% capture result_json %}\n      {\n        \"data\": {\n          \"collection\": {\n            \"id\": \"gid://shopify/Collection/1234567890\",\n            \"products\": {\n              \"edges\": [\n                {\n                  \"node\": {\n                    \"id\": \"gid://shopify/Product/2345678901\"\n                  }\n                }\n              ]\n            }\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = result_json | parse_json %}\n  {% endif %}\n\n  {% for product_edge in result.data.collection.products.edges %}\n    {% assign product = product_edge.node %}\n    {% assign product_ids_already_collected[product_ids_already_collected.size] = product.id %}\n  {% endfor %}\n\n  {% if result.data.collection.products.pageInfo.hasNextPage %}\n    {% assign cursor = result.data.collection.products.edges.last.cursor %}\n  {% else %}\n    {% break %}\n  {% endif %}\n{% endfor %}\n\n{% assign product_ids_under_consideration = product_ids_ordered | concat: product_ids_already_collected | uniq %}\n{% assign product_ids_to_have_at_the_end_of_the_day = array %}\n{% assign product_ids_to_add = array %}\n{% assign product_ids_to_remove = array %}\n\n{% for product_id in product_ids_under_consideration %}\n  {% if forloop.index <= collection_maximum_size %}\n    {% assign product_ids_to_have_at_the_end_of_the_day[product_ids_to_have_at_the_end_of_the_day.size] = product_id %}\n    {% unless product_ids_already_collected contains product_id %}\n      {% assign product_ids_to_add[product_ids_to_add.size] = product_id %}\n    {% endunless %}\n  {% else %}\n    {% assign product_ids_to_remove[product_ids_to_remove.size] = product_id %}\n  {% endif %}\n{% endfor %}\n\n{% assign mutations = array %}\n\n{% if product_ids_to_add != empty %}\n  {% capture mutation %}\n    collectionAddProducts(\n      id: {{ collection.admin_graphql_api_id | json }}\n      productIds: {{ product_ids_to_add | json }}\n    ) {\n      userErrors {\n        field\n        message\n      }\n    }\n  {% endcapture %}\n  {% assign mutations[mutations.size] = mutation %}\n{% endif %}\n\n{% if product_ids_to_remove != empty %}\n  {% capture mutation %}\n    collectionRemoveProducts(\n      id: {{ collection.admin_graphql_api_id | json }}\n      productIds: {{ product_ids_to_remove | json }}\n    ) {\n      userErrors {\n        field\n        message\n      }\n    }\n  {% endcapture %}\n  {% assign mutations[mutations.size] = mutation %}\n{% endif %}\n\n{% assign moves = array %}\n{% for product_id in product_ids_ordered %}\n  {% if product_ids_already_collected[forloop.index0] != product_id %}\n    {% capture move %}\n      {\n        id: {{ product_id | json }}\n        newPosition: {{ forloop.index0 | append: \"\" | json }}\n      }\n    {% endcapture %}\n    {% assign moves[moves.size] = move %}\n  {% endif %}\n{% endfor %}\n\n{% if moves != empty %}\n  {% capture mutation %}\n    collectionReorderProducts(\n      id: {{ collection.admin_graphql_api_id | json }}\n      moves: [\n        {{ moves | join: newline }}\n      ]\n    ) {\n      userErrors {\n        field\n        message\n      }\n    }\n  {% endcapture %}\n  {% assign mutations[mutations.size] = mutation %}\n{% endif %}\n\n{% if mutations != blank %}\n  {% action \"shopify\" %}\n    mutation {\n      {{ mutations | join: newline }}\n    }\n  {% endaction %}\n{% endif %}",
  "docs": "This task watches for newly-paid orders (or newly-fulfilled orders, if you choose), and adds or moves the purchased products to the top of the collection of your choice. Optionally, ignore products that are sold out. Useful for \"trending products\" functionality. :)\n\nThis task watches for newly-paid orders (or newly-fulfilled orders, if you choose), and adds or moves the ordered products to the top of the collection of your choice. Optionally, ignore products that are sold out.\r\n\r\nProvide this task with ID of a manual collection, which you've configured to be manually sorted. ([Learn how to find the collection ID.](https://help.usemechanic.com/en/articles/2946120-how-do-i-find-an-id-for-a-product-collection-order-or-something-else))\r\n\r\n[YouTube: Watch the development video!](https://youtu.be/89rxU1D5tFM)",
  "halt_action_run_sequence_on_error": false,
  "online_store_javascript": null,
  "order_status_javascript": null,
  "perform_action_runs_in_sequence": false,
  "tags": [
    "Collections",
    "Products"
  ]
}
