{
  "docs": "This demonstration task responds to product updates, by firing a custom event whenever it finds that any of the configured product and variant attributes have changed from a cached snapshot. This is useful for creating custom tasks without having to continually build the scaffolding of a specific attribute monitor in each of them.\n\nConfigure it with your custom event topic and a combination of product and/or variant attributes as desired. This task uses the GraphQL representation of the [Product](https://shopify.dev/docs/api/admin-graphql/latest/objects/Product) and [Variant](https://shopify.dev/docs/api/admin-graphql/latest/objects/ProductVariant) resources, and will only be able to interpet fields that return a single value at those two resource levels. This means you will not be able to enter connections to other resources (e.g. metafields) or fields that have subfields (e.g. featuredImage).\n\nThis demonstration task has been preconfigured with a custom event topic of **user/product/update_monitor**, **title** as the product attribute to monitor, and **price** and **sku** as the variant attributes to monitor.\n\nTo build custom tasks to respond to the custom events generated by this task, make sure to subscribe to the custom event topic that has been configured in this task. When firing the custom event, the *current* product resource will be sent along as the event data. This will include all of the configured attributes to monitor, but no other fields besides the IDs.\n\n**Important Notes:**\n- This task will **not** send along the previous product resource values, as the cached snapshot is hashed for comparison, without explicitly storing the field values themselves. \n- The GraphQL resource field names entered in as attributes to monitor must match the Shopify documentation exactly (case-sensitive).\n- After changing any of the attributes to monitor in the config of this task, run the task manually to have it cache the snapshot value for all products in the shop.\n- The task has an arbitraty limit of 25k products that it will paginate through. If your shop has more than that, or a very large amount of variants (and you are tracking changes to them), then consider converting this task to use [bulk operations](https://learn.mechanic.dev/core/shopify/read/bulk-operations) for the manual runs instead.",
  "halt_action_run_sequence_on_error": false,
  "name": "Demonstration: Trigger a custom event for specific product or variant changes",
  "online_store_javascript": null,
  "options": {
    "custom_event_topic__required": "user/product/update_monitor",
    "product_attributes_to_monitor__array": [
      "title"
    ],
    "variant_attributes_to_monitor__array": [
      "price",
      "sku"
    ]
  },
  "order_status_javascript": null,
  "perform_action_runs_in_sequence": false,
  "preview_event_definitions": [],
  "script": "{% assign custom_event_topic = options.custom_event_topic__required %}\n{% assign product_attributes = options.product_attributes_to_monitor__array %}\n{% assign variant_attributes = options.variant_attributes_to_monitor__array %}\n\n{% comment %}\n  -- chck to see if the custom event topic is in the right form, and that at least one attribute is configured to be monitored\n{% endcomment %}\n\n{% assign custom_event_topic_parts = custom_event_topic | split: \"/\" %}\n\n{% if custom_event_topic_parts[0] != \"user\" %}\n  {% error \"The custom event topic must start with 'user/'\" %}\n{% endif %}\n\n{% if custom_event_topic_parts.size != 3 %}\n  {% error \"The custom event topic should be in the form of 'user/[subject]/[verb]'\" %}\n{% endif %}\n\n{% if product_attributes == blank and variant_attributes == blank %}\n  {% error \"Enter at least one product attribute or variant attribute to monitor\" %}\n{% endif %}\n\n{% comment %}\n  -- sort the configured attributes, join them together in a string, and then hash them to use as part of the cache key\n{% endcomment %}\n\n{% assign sorted_product_attributes = product_attributes | sort %}\n{% assign sorted_variant_attributes = variant_attributes | sort %}\n{% assign cache_snapshot_id\n  = sorted_product_attributes\n  | concat: sorted_variant_attributes\n  | join: \"\"\n  | sha256\n%}\n\n{% log\n  config: \"for this task run\",\n  custom_event_topic: custom_event_topic,\n  product_attributes_to_monitor: sorted_product_attributes,\n  variant_attributes_to_monitor: sorted_variant_attributes,\n  cache_snapshot_id: cache_snapshot_id\n%}\n\n{% assign products = array %}\n\n{% if event.topic == \"shopify/products/update\" or event.topic == \"shopify/products/create\" %}\n  {% comment %}\n    -- get product data from GraphLQ instead of the product webhook/REST\n  {% endcomment %}\n\n  {% capture query %}\n    query {\n      product(id: {{ product.admin_graphql_api_id | json }}) {\n        id\n        legacyResourceId\n        {{ product_attributes | join: newline }}\n        {% if variant_attributes != blank -%}\n          variants(first: 100) {\n            nodes {\n              id\n              {{ variant_attributes | join: newline }}\n            }\n          }\n        {%- endif %}\n      }\n    }\n  {% endcapture %}\n\n  {% assign result = query | shopify %}\n\n  {% comment %}\n    -- remove the variants / nodes structure from the product if it exists\n  {% endcomment %}\n\n  {% assign products[0]\n    = result.data.product\n    | default: hash\n    | except: \"variants\"\n  %}\n\n  {% comment %}\n    -- if variant attributes are being monitored, then reattach the array at the product level (i.e. no nodes)\n  {% endcomment %}\n\n  {% if variant_attributes != blank %}\n    {% assign products[0][\"variants\"] = result.data.product.variants.nodes | default: array %}\n  {% endif %}\n\n{% elsif event.topic == \"mechanic/user/trigger\" %}\n  {% comment %}\n    -- get all products in the shop first; if being monitored, variants are queried by product later to avoid exceeding query cost limit\n  {% endcomment %}\n\n  {% assign cursor = nil %}\n\n  {% for n in (1..100) %}\n    {% capture query %}\n      query {\n        products(\n          first: 250\n          after: {{ cursor | json }}\n        ) {\n          pageInfo {\n            hasNextPage\n            endCursor\n          }\n          nodes {\n            id\n            legacyResourceId\n            {{ product_attributes | join: newline }}\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = query | shopify %}\n\n    {% assign products_batch = result.data.products.nodes %}\n\n    {% if variant_attributes == blank %}\n      {% comment %}\n        -- if there are no variant attribute lookups configured, then just concatenate the products from this result\n      {% endcomment %}\n\n      {% assign products = products | concat: products_batch %}\n\n    {% else %}\n      {% comment %}\n        -- loop through the products in this batch and query the variant attributes for each\n      {% endcomment %}\n\n      {% for product in products_batch %}\n        {% capture variants_query %}\n          query {\n            product(id: {{ product.id | json }}) {\n              variants(first: 100) {\n                nodes {\n                  id\n                  {{ variant_attributes | join: newline }}\n                }\n              }\n            }\n          }\n        {% endcapture %}\n\n        {% assign variants_result = variants_query | shopify %}\n\n        {% assign product_data = product %}\n        {% assign product_data[\"variants\"] = variants_result.data.product.variants.nodes %}\n\n        {% assign products = products | push: product_data %}\n      {% endfor %}\n    {% endif %}\n\n    {% if result.data.products.pageInfo.hasNextPage %}\n      {% assign cursor = result.data.products.pageInfo.endCursor %}\n    {% else %}\n      {% break %}\n    {% endif %}\n  {% endfor %}\n{% endif %}\n\n{% comment %}\n  -- use a simple product for event previews, since we don't know what attributes will be configured\n{% endcomment %}\n\n{% if event.preview %}\n  {% assign products[0] = hash %}\n  {% assign products[0][\"legacyResourceId\"] = \"1234567890\" %}\n{% endif %}\n\n{% comment %}\n  -- loop through the products(s) queried above, to check for updates to the configured attributes\n{% endcomment %}\n\n{% for product in products %}\n  {% comment %}\n    -- generate the product specific cache key in combination with the configured attributes\n  {% endcomment %}\n\n  {% assign cache_key\n    = \"product_\"\n    | append: product.legacyResourceId\n    | append: \"_snapshot_\"\n    | append: cache_snapshot_id\n  %}\n\n  {% assign cache_value = cache[cache_key] %}\n  {% assign expected_cache_value = product | json | sha256 %}\n\n  {% comment %}\n    -- check if a cache value exists and is the same as the expected value; if so, move to next product\n  {% endcomment %}\n\n  {% if cache_value == expected_cache_value %}\n    {% log\n      message: \"Product has no changes to the configured attributes.\",\n      product_id: product.id\n    %}\n    {% continue %}\n  {% endif %}\n\n  {% comment %}\n    -- fire the configured custom event if a different cache value exists\n  {% endcomment %}\n\n  {% if cache_value != blank or event.preview %}\n    {% action \"event\" %}\n      {\n        \"topic\": {{ custom_event_topic | json }},\n        \"data\": {{ product | json }}\n      }\n    {% endaction %}\n\n  {% else %}\n    {% log\n      message: \"Product does not have a cached snapshot for this combination of product and/or variant attributes; setting it now, but will not trigger the custom event on this task run.\",\n      product: product\n    %}\n  {% endif %}\n\n  {% comment %}\n    -- save a hash of the product data in the cache with default expiration of 60 days\n  {% endcomment %}\n\n  {% action \"cache\", \"set\", cache_key, expected_cache_value %}\n{% endfor %}\n",
  "subscriptions": [
    "shopify/products/update",
    "mechanic/user/trigger",
    "shopify/products/create"
  ],
  "subscriptions_template": "shopify/products/update\nmechanic/user/trigger\nshopify/products/create",
  "tags": [
    "Demonstration",
    "Products",
    "Variants",
    "Watch"
  ]
}
