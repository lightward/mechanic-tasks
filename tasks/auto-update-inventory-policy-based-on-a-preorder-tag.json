{
  "docs": "This task scans your product catalog nightly or when you hit the \"Run task\" button, checking for the presence of a \"preorder\" tag, or a tag that starts with \"preorder_\" (like \"preorder_summer\"). If this tag is found, the task updates the product to allow customers to purchase the product after it's out of stock. If no preorder tag is found, the task makes sure customers *cannot* purchase the product if it's out of stock.\n\nOptionally, choose whether to \"Run on product create and update instead of daily\", which includes events such as product tagging, inventory level adjustments, and inventory policy changes.\n\nNotes:\n\n* For efficiency, this task only scans _published_ products in your catalog.",
  "halt_action_run_sequence_on_error": false,
  "name": "Auto-update inventory policy based on a \"preorder\" tag",
  "online_store_javascript": null,
  "options": {
    "run_on_product_create_and_update_instead_of_daily__boolean": false
  },
  "order_status_javascript": null,
  "perform_action_runs_in_sequence": false,
  "script": "{% if event.topic == \"shopify/products/create\" or event.topic == \"shopify/products/update\" %}\n  {% comment %}\n    -- only check published products\n  {% endcomment %}\n\n  {% if product.published_at == blank %}\n    {% unless event.preview %}\n      {% log \"Product is not published; skipping scan\" %}\n      {% break %}\n    {% endunless %}\n  {% endif %}\n\n  {% comment %}\n    -- query product and variant data, up to 2K variants\n  {% endcomment %}\n\n  {% assign products = array %}\n  {% assign variants = array %}\n  {% assign cursor = nil %}\n\n  {% for n in (1..8) %}\n    {% capture query %}\n      query {\n        product(id: {{ product.admin_graphql_api_id | json }}) {\n          id\n          tags\n          variants(\n            first: 250\n            after: {{ cursor | json }}\n          ) {\n            pageInfo {\n              hasNextPage\n              endCursor\n            }\n            nodes {\n              id\n              inventoryPolicy\n            }\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% assign result = query | shopify %}\n\n    {% if event.preview %}\n      {% capture result_json %}\n        {\n          \"data\": {\n            \"product\": {\n              \"id\": \"gid://shopify/Product/1234567890\",\n              \"tags\": \"preorder\",\n              \"variants\": {\n                \"nodes\": [\n                  {\n                    \"id\": \"gid://shopify/ProductVariant/1234567890\",\n                    \"inventoryPolicy\": \"DENY\"\n                  }\n                ]\n              }\n            }\n          }\n        }\n      {% endcapture %}\n\n      {% assign result = result_json | parse_json %}\n    {% endif %}\n\n    {% comment %}\n      -- only save the product ID and tags from the product object; a separate array is used to support 2K variants\n    {% endcomment %}\n\n    {% assign products[0] = result.data.product | except: \"variants\" %}\n    {% assign variants = variants | concat: result.data.product.variants.nodes %}\n\n    {% if result.data.product.variants.pageInfo.hasNextPage %}\n      {% assign cursor = result.data.product.variants.pageInfo.endCursor %}\n    {% else %}\n      {% break %}\n    {% endif %}\n  {% endfor %}\n\n{% elsif event.topic == \"mechanic/user/trigger\" or event.topic contains \"mechanic/scheduler/\" %}\n  {% comment %}\n    -- get all published products in the shop, and all of their variants\n  {% endcomment %}\n\n  {% capture bulk_operation_query %}\n    query {\n      products(\n        query: \"gift_card:false published_status:published\"\n      ) {\n        edges {\n          node {\n            __typename\n            id\n            tags\n            variants {\n              edges {\n                node {\n                  __typename\n                  id\n                  inventoryPolicy\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  {% endcapture %}\n\n  {% action \"shopify\" %}\n    mutation {\n      bulkOperationRunQuery(\n        query: {{ bulk_operation_query | json }}\n      ) {\n        bulkOperation {\n          id\n          status\n        }\n        userErrors {\n          field\n          message\n        }\n      }\n    }\n  {% endaction %}\n\n  {% break %}\n\n{% elsif event.topic == \"mechanic/shopify/bulk_operation\" %}\n  {% if event.preview %}\n    {% capture jsonl_string %}\n      {\"__typename\":\"Product\",\"id\":\"gid://shopify/Product/1234567890\",\"tags\":[\"preorder\"]}\n      {\"__typename\":\"ProductVariant\",\"id\":\"gid://shopify/ProductVariant/1234567890\",\"inventoryPolicy\":\"DENY\",\"__parentId\":\"gid://shopify/Product/1234567890\"}\n    {% endcapture %}\n\n    {% assign bulkOperation = hash %}\n    {% assign bulkOperation[\"objects\"] = jsonl_string | parse_jsonl %}\n  {% endif %}\n\n  {% comment %}\n    -- products and variants will be separate lines in the JSONL, so filter them into their own arrays\n    -- match variants to their parents in the products processing loop (this prevents creating another potentially large array in memory)\n  {% endcomment %}\n\n  {% assign products = bulkOperation.objects | where: \"__typename\", \"Product\" %}\n  {% assign bulk_variants = bulkOperation.objects | where: \"__typename\", \"ProductVariant\" %}\n{% endif %}\n\n{% comment %}\n  -- using products array, either process the product which triggered the event, or all products from bulk op query\n{% endcomment %}\n\n{% for product in products %}\n  {% if event.topic == \"mechanic/shopify/bulk_operation\" %}\n    {% assign variants = bulk_variants | where: \"__parentId\", product.id %}\n  {% endif %}\n\n  {% comment %}\n    -- overselling should be disabled unless this product has a preorder tag\n  {% endcomment %}\n\n  {% assign expected_inventory_policy = \"DENY\" %}\n\n  {% for tag in product.tags %}\n    {% assign tag_parts = tag | split: \"_\" %}\n\n    {% if tag_parts[0] == \"preorder\" %}\n      {% assign expected_inventory_policy = \"CONTINUE\" %}\n      {% break %}\n    {% endif %}\n  {% endfor %}\n\n  {% comment %}\n    -- save GraphQL mutation inputs for variants that need to have their inventory policy updated to match what is expected based on product tags\n  {% endcomment %}\n\n  {% assign variant_inputs = array %}\n\n  {% for variant in variants %}\n    {% if variant.inventoryPolicy != expected_inventory_policy %}\n      {% assign variant_input = hash %}\n      {% assign variant_input[\"id\"] = variant.id %}\n      {% assign variant_input[\"inventoryPolicy\"] = expected_inventory_policy %}\n      {% assign variant_inputs = variant_inputs | push: variant_input %}\n    {% endif %}\n  {% endfor %}\n\n  {% if variant_inputs != blank %}\n    {% comment %}\n      -- pass variant inputs as GraphQL variables to handle products with a very large number of variants to update\n    {% endcomment %}\n\n    {% assign variables = hash %}\n    {% assign variables[\"variants\"] = variant_inputs %}\n\n    {% capture query %}\n      mutation productVariantsBulkUpdate($variants: [ProductVariantsBulkInput!]!) {\n        productVariantsBulkUpdate(\n          productId: {{ product.id | json }}\n          variants: $variants\n        ) {\n          product {\n            id\n            title\n            tags\n          }\n          userErrors {\n            field\n            message\n          }\n        }\n      }\n    {% endcapture %}\n\n    {% action \"shopify\" query: query, variables: variables %}\n  {% endif %}\n{% endfor %}\n",
  "subscriptions": [
    "mechanic/scheduler/daily",
    "mechanic/user/trigger"
  ],
  "subscriptions_template": "{% if options.run_on_product_create_and_update_instead_of_daily__boolean %}\n  shopify/products/create\n  shopify/products/update\n{% else %}\n  mechanic/scheduler/daily\n{% endif %}\nmechanic/shopify/bulk_operation\nmechanic/user/trigger",
  "tags": [
    "Auto-Update",
    "Products",
    "Tag",
    "Watch"
  ]
}
