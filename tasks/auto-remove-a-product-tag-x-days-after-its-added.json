{
  "name": "Auto-remove a product tag x days after it's added",
  "options": {
    "tag_to_monitor__required": null,
    "days_to_wait_before_untagging__number_required": null
  },
  "subscriptions": [
    "shopify/products/create",
    "shopify/products/update",
    "user/task/untag_product"
  ],
  "subscriptions_template": "shopify/products/create\nshopify/products/update\nuser/task/untag_product",
  "script": "{% if event.topic == \"user/task/untag_product\" %}\n  {% assign product_id = event.data.product_id %}\n{% else %}\n  {% assign product_id = product.admin_graphql_api_id %}\n{% endif %}\n\n{% assign tag = options.tag_to_monitor__required %}\n{% assign untag_flag_tag = tag | append: \" - will be auto-removed by Mechanic\" %}\n{% assign tag_removal_interval_s = options.days_to_wait_before_untagging__number_required | times: 24 | times: 60 | times: 60 %}\n{% assign now_s = \"now\" | date: \"%s\" | times: 1 %}\n{% assign metafield_key = task.id | sha256 | slice: 0, 7 %}\n\n{% capture query %}\n  query {\n    product(id: {{ product_id | json }}) {\n      id\n      tags\n      metafield(\n        namespace: \"mechanic\"\n        key: {{ metafield_key | json }}\n      ) {\n        id\n        value\n      }\n    }\n  }\n{% endcapture %}\n\n{% assign result = query | shopify %}\n\n{% if event.preview %}\n  {% capture result_json %}\n    {\n      \"data\": {\n        \"product\": {\n          \"id\": \"gid://shopify/Product/1234567890\",\n          \"tags\": [{{ tag | json }}],\n          \"metafield\": null\n        }\n      }\n    }\n  {% endcapture %}\n\n  {% assign result = result_json | parse_json %}\n{% endif %}\n\n{% assign product = result.data.product %}\n\n{% if product.tags contains tag %}\n  {% assign time_to_remove_s = product.metafield.value | times: 1 %}\n\n  {% if product.metafield == nil or time_to_remove_s == 0 %}\n    {% action \"shopify\" %}\n      mutation {\n        tagsAdd(\n          id: {{ product.id | json }}\n          tags: {{ untag_flag_tag | json }}\n        ) {\n          node {\n            ... on Product {\n              tags\n            }\n          }\n          userErrors {\n            field\n            message\n          }\n        }\n\n        productUpdate(\n          input: {\n            id: {{ product.id | json }}\n            metafields: [\n              {\n                namespace: \"mechanic\"\n                key: {{ metafield_key | json }}\n                value: {{ \"now\" | date: \"%s\" | plus: tag_removal_interval_s | append: \"\" | json }}\n                valueType: INTEGER\n                description: {{ \"Auto-removal time for product tag \" | append: tag | append: \", for task \" | append: task.id | json }}\n              }\n            ]\n          }\n        ) {\n          product {\n            metafield(\n              namespace: \"mechanic\"\n              key: {{ metafield_key | json }}\n            ) {\n              id\n            }\n          }\n          userErrors {\n            field\n            message\n          }\n        }\n      }\n    {% endaction %}\n\n    {% action \"event\" %}\n      {\n        \"topic\": \"user/task/untag_product\",\n        \"data\": {\n          \"product_id\": {{ product.id | json }}\n        },\n        \"run_at\": {{ now_s | plus: tag_removal_interval_s | round | json }},\n        \"task_id\": {{ task.id | json }}\n      }\n    {% endaction %}\n  {% elsif product.tags contains untag_flag_tag %}\n    {% if now_s < time_to_remove_s %}\n      {% log message: \"This product is scheduled to be untagged, but it's not time yet. Skipping.\", tag: tag, untag_flag_tag: untag_flag_tag, now_s: now_s, time_to_remove_s: time_to_remove_s %}\n    {% else %}\n      {% log message: \"This product is scheduled to be untagged, and that time is now.\", tag: tag, untag_flag_tag: untag_flag_tag, now_s: now_s, time_to_remove_s: time_to_remove_s %}\n      {% action \"shopify\" %}\n        mutation {\n          tagsRemove(\n            id: {{ product.id | json }}\n            tags: [{{ tag | json }}, {{ untag_flag_tag | json }}]\n          ) {\n            node {\n              ... on Product {\n                tags\n              }\n            }\n            userErrors {\n              field\n              message\n            }\n          }\n\n          metafieldDelete(\n            input: {\n              id: {{ product.metafield.id | json }}\n            }\n          ) {\n            userErrors {\n              field\n              message\n            }\n          }\n        }\n      {% endaction %}\n    {% endif %}\n  {% else %}\n    {% log message: \"This product has a tag removal time recorded, but the 'untag flag tag' has been removed. Skipping.\", tag: tag, untag_flag_tag: untag_flag_tag, now_s: now_s, time_to_remove_s: time_to_remove_s %}\n  {% endif %}\n{% elsif event.topic == \"user/task/untag_product\" %}\n  {% log message: \"The tag auto-removal event has arrived, but the product has already been untagged by someone/something else. Skipping.\", tag: tag, product_tags: product.tags %}\n{% endif %}",
  "docs": "Use this this task to monitor for the addition of a new product tag, and to schedule the product to be untagged some number of days later. Useful for temporarily adding a product to a collection, or qualifying the product for some other temporary functionality.\n\nThis task monitors new and updated products, watching for the configured product tag.\r\n\r\nAs soon as that tag is detected, the task will _add_ a second tag, indicating that the product is scheduled to be untagged. (For example, if the task is configured to watch for the tag \"Approved\", the task will _add_ the tag \"Approved - will be auto-removed by Mechanic\".) The task will then schedule a followup event for the future, according to the configured number of days to wait. At that time, the task will remove both tags.\r\n\r\nImportant note: To _prevent_ the task from untagging the product later, manually remove the task's additional tag (i.e. the \"will be auto-removed by Mechanic\" tag). If the additional tag is found missing, the task will leave the tag in place instead of auto-removing it.",
  "halt_action_run_sequence_on_error": false,
  "online_store_javascript": null,
  "order_status_javascript": null,
  "perform_action_runs_in_sequence": false
}
